#ifndef INCLUDED_BOBCAT_TYPETRAIT_
#define INCLUDED_BOBCAT_TYPETRAIT_

namespace FBB
{

template <typename T>
class TypeTrait
{
    template <typename U> struct Type
    {
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = sizeof(fun<U>(0)) == sizeof(double) };
        enum { isDereferenceable = isClass};
        enum { isPointer = false };
        enum { isConst   = false };
        enum { isRef     = false };
        enum { isR_Ref   = false };

        typedef U Plain;
    };
    template <typename U> struct Type<U const>
    {
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = sizeof(fun<U>(0)) == sizeof(double) };
        enum { isDereferenceable = isClass};
        enum { isPointer = false };
        enum { isConst   = true };
        enum { isRef     = false };
        enum { isR_Ref   = false };

        typedef U Plain;
    };
    template <typename U> struct Type<U *>
    {
        enum { isClass = false };
        enum { isDereferenceable = true };
        enum { isPointer = true };
        enum { isConst   = false };
        enum { isRef     = false };
        enum { isR_Ref   = false };

        typedef U Plain;
    };
    template <typename U> struct Type<U const *>
    {
        enum { isClass = false };
        enum { isDereferenceable = true };
        enum { isPointer = true };
        enum { isConst   = true };
        enum { isRef     = false };
        enum { isR_Ref   = false };

        typedef U Plain;
    };
    template <typename U> struct Type<U &>
    {
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = sizeof(fun<U>(0)) == sizeof(double) };
        enum { isDereferenceable = isClass};
        enum { isPointer = false };
        enum { isConst   = false };
        enum { isRef     = true };
        enum { isR_Ref   = false };

        typedef U Plain;
    };
    template <typename U> struct Type<U const &>
    {
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = sizeof(fun<U>(0)) == sizeof(double) };
        enum { isDereferenceable = isClass};
        enum { isPointer = false };
        enum { isConst   = true };
        enum { isRef     = true };
        enum { isR_Ref   = false };

        typedef U Plain;
    };
    template <typename U> struct Type<U &&>
    {
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = sizeof(fun<U>(0)) == sizeof(double) };
        enum { isDereferenceable = isClass};
        enum { isPointer = false };
        enum { isConst   = false };
        enum { isRef     = false };
        enum { isR_Ref   = true  };

        typedef U Plain;
    };
    template <typename U> struct Type<U const &&>
    {
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = sizeof(fun<U>(0)) == sizeof(double) };
        enum { isDereferenceable = isClass};
        enum { isPointer = false };
        enum { isConst   = true };
        enum { isRef     = false };
        enum { isR_Ref   = true  };

        typedef U Plain;
    };

    public:
        template <typename ClassType>
        static double fun(void (ClassType::*)());
    
        template <typename NonClassType>
        static char fun(...);

        enum { isClass = Type<T>::isClass };
        enum { isDereferenceable = Type<T>::isDereferenceable };
        enum { isPointer = Type<T>::isPointer };
        enum { isConst   = Type<T>::isConst };
        enum { isRef     = Type<T>::isRef };
        enum { isR_Ref   = Type<T>::isR_Ref };
        
        typedef typename Type<T>::Plain Plain;
};

template <typename L, typename R>
class LpromotesR
{
    struct Char2
    {
        char array[2];
    };
    static R const &makeR();
    static char test(L const &);
    static Char2 test(...);

    public:
        LpromotesR() = delete;
        enum { yes = sizeof(test(makeR())) == sizeof(char) };
};

template <bool ifTrue, typename True, typename False>
struct IfElse
{
    IfElse() = delete;
    typedef False type;
};

template <typename True, typename False>
struct IfElse<true, True, False>
{
    IfElse() = delete;
    typedef True type;
};

} // FBB

#endif
