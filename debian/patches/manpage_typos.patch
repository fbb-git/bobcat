Description: correct a few typos
Author: tony mancill <tmancill@debian.org>
Forwarded: https://github.com/fbb-git/bobcat/pull/3 

--- a/documentation/man/clientsocket.yo
+++ b/documentation/man/clientsocket.yo
@@ -18,7 +18,7 @@
 bf(std::istream) is used to read information from the server process to which
 the bf(FBB::ClientSocket) connects, The bf(std::ostream) is used to send
 information to the server process to which the bf(FBB::ClientSocket) connects.
-Since a socket may be considered a em(file descriptor) the avaiable
+Since a socket may be considered a em(file descriptor) the available
 bf(FBB::IFdStream), bf(FBB::IFdStreamBuf), bf(FBB::OFdStream), and
 bf(FBB::OFdStreamBuf) classes may be used profitably here. Note that having
 available a socket does not mean that this defines the communication
--- a/documentation/man/csv.yo
+++ b/documentation/man/csv.yo
@@ -7,7 +7,7 @@
 manpage(FBB::CSV)(3bobcat)(_CurYrs_)(libbobcat-dev__CurVers_-x.tar.gz)
                     (CSV convertor)
 
-manpagename(FBB::CSV)(Convertor for comma separated values)
+manpagename(FBB::CSV)(Converter for comma separated values)
 
 manpagesynopsis()
     bf(#include <bobcat/csv>)nl()
--- a/documentation/man/diffiehellman.yo
+++ b/documentation/man/diffiehellman.yo
@@ -73,7 +73,7 @@
 peer or initiator `in the clear', but encrypted using the long-lasting common
 secret. As the current implementation saves all public information on file,
 it's probably easiest to encrypt the file containing the public information.
-    it() The recipients, having recieved the other party's encrypted public
+    it() The recipients, having received the other party's encrypted public
 information, decrypt it using the long-lasting shared secret and compute the
 the shared key.
     it() As the secret information is not kept, the shared key cannot be
--- a/documentation/man/isymcryptstream.yo
+++ b/documentation/man/isymcryptstream.yo
@@ -65,8 +65,8 @@
     - The internally used tt(IFilterStreambuf) is initialized with a buffer of
 size tt(filterBufSize), using a lower bound of 100;nl()
     - The parameter tt(ENGINE) can be used to specify a hardware
-accelleration engine, as supported by the used encryption/decryption
-method. Its default argument value indicates that no hardware accelleration is
+acceleration engine, as supported by the used encryption/decryption
+method. Its default argument value indicates that no hardware acceleration is
 available.
     )
 
--- a/documentation/man/isymcryptstreambuf.yo
+++ b/documentation/man/isymcryptstreambuf.yo
@@ -99,8 +99,8 @@
 initialized with a buffer of size tt(filterBufSize), using a lower bound
 of 100;nl()
     - The parameter tt(ENGINE) can be used to specify a hardware
-accelleration engine, as supported by the used encryption/decryption
-method. Its default argument value indicates that no hardware accelleration is
+acceleration engine, as supported by the used encryption/decryption
+method. Its default argument value indicates that no hardware acceleration is
 available.
         )
     )
--- a/documentation/man/localserversocket.yo
+++ b/documentation/man/localserversocket.yo
@@ -22,7 +22,7 @@
 descriptor) which may be used to initialize a bf(std::istream) and/or
 bf(std::ostream). The bf(std::istream) is used to read information from the
 client process; the bf(std::ostream) is used to send information to the client
-process.  Since a socket may be considered a em(file descriptor) the avaiable
+process.  Since a socket may be considered a em(file descriptor) the available
 bf(FBB::IFdStream), bf(FBB::IFdStreamBuf), bf(FBB::OFdStream), and
 bf(FBB::OFdStreamBuf) classes may be used profitably here. Note that having
 available a socket does not mean that this defines the communication
--- a/documentation/man/serversocket.yo
+++ b/documentation/man/serversocket.yo
@@ -22,7 +22,7 @@
 bf(std::istream) and/or bf(std::ostream). The bf(std::istream) is used to read
 information from the client process; the bf(std::ostream) is used to send
 information to the client process.  Since a socket may be considered a em(file
-descriptor) the avaiable bf(FBB::IFdStream), bf(FBB::IFdStreamBuf),
+descriptor) the available bf(FBB::IFdStream), bf(FBB::IFdStreamBuf),
 bf(FBB::OFdStream), and bf(FBB::OFdStreamBuf) classes may be used profitably
 here. Note that having available a socket does not mean that this defines the
 communication protocol. It is (still) the responsibility of the programmer to
--- a/sharedmemory/insert.cc
+++ b/sharedmemory/insert.cc
@@ -3,7 +3,7 @@
 ostream &SharedMemory::insert(ostream &out) const
 {
     if (d_sharedSegment == 0)
-        return out << "No shared data avaiable";
+        return out << "No shared data available";
 
     out << "ID of shared memory segment: " << d_id << '\n';
     
--- a/documentation/man/iostreambuf.yo
+++ b/documentation/man/iostreambuf.yo
@@ -21,7 +21,7 @@
 
     If the streams that will be associated with the bf(IOStreambuf) object
 support seeking, then the bf(IOStreambuf) will do so to. Seeking might also be
-availble for a single stream (either the bf(std::istream) or the
+available for a single stream (either the bf(std::istream) or the
 bf(std::ostream)). 
 
 When the bf(IOStreambuf) object goes out of scope, its associated
--- a/documentation/man/localclientsocket.yo
+++ b/documentation/man/localclientsocket.yo
@@ -20,7 +20,7 @@
 server process to which the bf(FBB::LocalClientSocket) connects, The
 bf(std::ostream) is used to send information to the server process to which
 the bf(FBB::LocalClientSocket) connects.  Since a socket may be considered a
-em(file descriptor) the avaiable bf(FBB::IFdStream), bf(FBB::IFdStreamBuf),
+em(file descriptor) the available bf(FBB::IFdStream), bf(FBB::IFdStreamBuf),
 bf(FBB::OFdStream), and bf(FBB::OFdStreamBuf) classes may be used profitably
 here. Note that having available a socket does not mean that this defines the
 communication protocol. It is (still) the responsibility of the programmer to
--- a/documentation/man/sharedpos.yo
+++ b/documentation/man/sharedpos.yo
@@ -78,7 +78,7 @@
        Returns tt(true) if offset exceeds the maximum offset of any character
         ever written to the shared memory to which the bf(SharedPos) object
         interfaces. If tt(eof) returns tt(true) information may still be
-        em(written) to the shared memory: writting is possible until the
+        em(written) to the shared memory: writing is possible until the
         maximum shared memory segment offset has been reached.
 
     itb(std::streamsize eos() const)
--- a/documentation/man/sharedsegment.yo
+++ b/documentation/man/sharedsegment.yo
@@ -120,7 +120,7 @@
 
     itb(size_t segmentSize() const)
        Returns the size (in bytes) of the shared memory data blocks. The
-        bf(SharedSegment) object can accomodate at most tt(segmentSize() *
+        bf(SharedSegment) object can accommodate at most tt(segmentSize() *
         nBlocks()) bytes.
 
     itb(bool truncate(std::streamsize offset))
