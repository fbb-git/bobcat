#include "configfile"

#include <algorithm>
#include <fstream>
#include <cstring>

#include <bobcat/pattern>
#include <bobcat/errno>
#include "../iuo/iuo"

using namespace std;
using namespace FBB;

//    Lines are stored with initial WS removed.
//    If a line ends in \, then the next line (initial WS removed)
//    is appended to the current line.
//    Information at and beyond the first # on individual lines is removed
//    if the rmComment flag is set to true (\# is converted to a #-character)
//    Then, lines containing only blanks and tabs are not stored

namespace FBB
{

class ConfigFile__: public CFEnums__
{
    std::vector<std::string> d_line;

    bool d_rmComment;
    bool d_caseSensitive;
    bool d_indices;
    size_t d_rawIndex;        
    size_t d_nextIndex;        
    std::vector<size_t> d_index;

                            // contains iterators to lines matching REs
    typedef std::vector<std::string>::const_iterator VsIterator;
    typedef std::vector<VsIterator> VsIterVector;
    VsIterVector d_vsIter;
    std::string d_re;

    mutable Pattern d_pattern;

    public:
        explicit ConfigFile__(Comment cType = KeepComment, 
                   SearchCasing sType = SearchCaseSensitive,
                   Indices iType = IgnoreIndices);

                                                // Name of the config file
        explicit ConfigFile__(std::string const &fname,
                    Comment cType = KeepComment, 
                    SearchCasing sType = SearchCaseSensitive,
                    Indices iType = IgnoreIndices);

        ConfigFile__(ConfigFile__ const &rhs) = default;
        ConfigFile__(ConfigFile__ &&tmp) = default;

        ConfigFile__ &operator=(ConfigFile__ &&tmp) = default;
        ConfigFile__ &operator=(ConfigFile__ const &rhs) = default;

        void setCommentHandling(Comment type);
        void setSearchCasing(SearchCasing type);
        void open(std::string const &fname);

        const_iterator begin() const;
        const_iterator end() const;

        const_RE_iterator beginRE(std::string const &re);
        const_RE_iterator endRE() const;

        std::pair<const_RE_iterator, const_RE_iterator> 
                            beginEndRE(std::string const &re);

        const_iterator find(std::string const &target) const;
        const_iterator findRE(std::string const &re) const;

        std::string findKey(std::string const &key, size_t count);
        std::string findKeyTail(std::string const &key, size_t count);

        size_t index(size_t lineNr);
        size_t index(const_iterator const &iterator);

        std::string const &operator[](size_t idx) const;

        size_t size() const;

    private:
        static void trimLeft(std::string &line);
        static void trimRight(std::string &line, bool appendNext);
        bool rmCommentAndEscapes(std::string &line);
        bool nextLine(std::istream &inStream, std::string &dest);

        void resetVsIter(std::string const &re);
        std::string searchFor(std::string const &keyPattern, size_t count);

        static bool finder(std::string const &haystack, 
                           std::string const &needle);
        static bool casefinder(std::string const &haystack, 
                               std::string const &needle);
};

} // FBB

inline bool ConfigFile__::finder(string const &haystack, string const &needle)
{
    return haystack.find(needle) != string::npos;
}

inline bool ConfigFile__::casefinder(string const &haystack, 
                                    string const &needle)
{
    return strcasestr(haystack.c_str(), needle.c_str()) != 0;
}

inline size_t ConfigFile__::size() const
{
    return d_line.size();
}

inline std::string const &ConfigFile__::operator[](size_t idx) const
{
    return d_line[idx];
}

inline size_t ConfigFile__::index(const_iterator const &iterator)
{
    return d_index[iterator - begin()];
}

inline size_t ConfigFile__::index(size_t lineNr)
{
    return d_index[lineNr];
}

inline string ConfigFile__::findKeyTail(string const &keyPattern, size_t count)
{
    return searchFor("^\\s*" + keyPattern + "\\s+(.*)\\s*$", count);
}

inline string ConfigFile__::findKey(string const &keyPattern, size_t count)
{
    return searchFor("^\\s*" + keyPattern + "\\s+(\\S+)", count);
}

inline ConfigFile__::const_RE_iterator ConfigFile__::endRE() const
{
    return RE_iterator(d_vsIter, d_vsIter.size());
}

inline ConfigFile__::const_iterator ConfigFile__::begin() const
{
    return d_line.begin();
}
   
inline ConfigFile__::const_iterator ConfigFile__::end() const
{
    return d_line.end();
}
   
inline void ConfigFile__::setSearchCasing(SearchCasing type)
{
    d_caseSensitive = type == SearchCaseSensitive;
}

inline void ConfigFile__::setCommentHandling(Comment type)
{
    d_rmComment = type == RemoveComment;
}




