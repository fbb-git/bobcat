#include "configfile"

#include <algorithm>
#include <fstream>
#include <climits>
#include <cstring>

#include <bobcat/pattern>
#include <bobcat/errno>
// #include <bobcat/fswap>

using namespace std;
using namespace FBB;

//    Lines are stored with initial WS removed.
//    If a line ends in \, then the next line (initial WS removed)
//    is appended to the current line.
//    Information at and beyond the first # on individual lines is removed
//    if the rmComment flag is set to true
//    Then, lines containing only blanks and tabs are not stored

namespace FBB
{

class ConfigFile__: public CFEnums__
{
    std::vector<std::string> d_line;

    bool d_rmComment;
    bool d_caseSensitive;
    bool d_indices;
    size_t d_rawIndex;        
    size_t d_nextIndex;        
    std::vector<size_t> d_index;

                            // contains iterators to lines matching REs
    typedef std::vector<std::string>::const_iterator VsIterator;
    typedef std::vector<VsIterator> VsIterVector;
    VsIterVector d_vsIter;
    std::string d_re;

    mutable Pattern d_pattern;

    public:
        explicit ConfigFile__(Comment cType = KeepComment, 
                   SearchCasing sType = SearchCaseSensitive,
                   Indices iType = IgnoreIndices);

                                                // Name of the config file
        explicit ConfigFile__(std::string const &fname,
                    Comment cType = KeepComment, 
                    SearchCasing sType = SearchCaseSensitive,
                    Indices iType = IgnoreIndices);

        ConfigFile__(ConfigFile__ const &rhs) = default;
        ConfigFile__(ConfigFile__ &&tmp) = default;

        ConfigFile__ &operator=(ConfigFile__ &&tmp) = default;
        ConfigFile__ &operator=(ConfigFile__ const &rhs) = default;

        void setCommentHandling(Comment type);
        void setSearchCasing(SearchCasing type);
        void open(std::string const &fname);

        const_iterator begin() const;
        const_iterator end() const;

        const_RE_iterator beginRE(std::string const &re);
        const_RE_iterator endRE() const;

        std::pair<const_RE_iterator, const_RE_iterator> 
                            beginEndRE(std::string const &re);

        const_iterator find(std::string const &target) const;
        const_iterator findRE(std::string const &re) const;

        std::string findKey(std::string const &key, size_t count);
        std::string findKeyTail(std::string const &key, size_t count);

        size_t index(size_t lineNr);
        size_t index(const_iterator const &iterator);

        std::string const &operator[](size_t idx) const;

        size_t size() const;

    private:
        size_t append_next(std::istream &istr, std::string &line);
        bool hasContent(std::string const &line);
        bool nextLine(std::istream &istr, std::string &line);
        void removeComment(std::string &line);
        void removeTrailingBlanks(std::string &line);
        void resetVsIter(std::string const &re);
        std::string searchFor(std::string const &keyPattern, size_t count);

        static bool finder(std::string const &haystack, 
                           std::string const &needle);
        static bool casefinder(std::string const &haystack, 
                               std::string const &needle);
};

} // FBB

inline bool ConfigFile__::finder(string const &haystack, string const &needle)
{
    return haystack.find(needle) != string::npos;
}

inline bool ConfigFile__::casefinder(string const &haystack, 
                                    string const &needle)
{
    return strcasestr(haystack.c_str(), needle.c_str()) != 0;
}
