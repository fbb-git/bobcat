includefile(header.inc)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(FBB::Wrap1)(3bobcat)(_CurYrs_)(bobcat-dev__CurVers_-x.tar.gz)
                    (Unary Wrapper)

manpagename(FBB::Wrap1)(STL unary argument wrapper template class)

manpagesynopsis()
    bf(#include <bobcat/wrap1>)nl()

manpagedescription()
    The bf(FBB::Wrap1) class is a configurable unary argument wrapper template
class. Its primary use is in combination with the generic algorithms of the
standard template libray.

    The callled function itself may be specified as one of the constructor's
arguments. It must be a (static member) function. Using a (static member)
function has various advantages, especially with the bf(Wrap?c) classes to
which a em(local context) can be passed:
    itemization(
    it() There is no introduced uncertainty about the bf(const)-ness of the
callled function, as static member functions do not support 
a bf(const) modifier;
    it() The passed function can also be a free (global) function to which a
local context is passed;
    it() The passed function can be a static member function of the class
using the generic algorithm to which the c() object is passed. By passing 
the calling object in the function's local context, the function may directly
access the calling object's members.
    it() The passed function can be a static member function of the class
whose objects are passed to the function via the generic template function s
iterator parameters. In that case the function may directly access the passed
object's members.
    it() Since no object is involved in calling the static function, no
ambiguity can arise as to whether an object reference or an object pointer
should be used in calling the function: static (member) functions may be
called without using objects.
    )

    The bf(FBB::Wrap1) template class has the following template parameters:
    itemization(
    itt(Type): the type of the object passed to bf(FBB::Wrap1)'s
bf(operator()()) function. Specify a bf(plain) type, do not specify a pointer
or reference type: if pointers or references are used, it will become obvious
later on, as the template will be able to handle (const) references and
pointers. Values of primitive types may be handled as const-references.
    itt(ReturnType): the bf(ReturnType) is by default defined as tt(void). By
specifying another type, the bf(FBB::Wrap1) object's bf(operator()()) function
will pass the called function's return value as a value of the specified
type. E.g, by specifying a tt(bool) bf(ReturnType), the bf(FBB::Wrap1) object
may be used as a em(Unary Predicate)
    )

manpagesection(NAMESPACE)
    bf(FBB)nl()
    All constructors, members, operators and manipulators, mentioned in this
man-page, are defined in the namespace bf(FBB).


manpagesection(INHERITS FROM)
    -

manpagesection(CONSTRUCTORS)
    itemization(
    itb(Wrap1<Type [, Returntype = void]>(ReturnType (*fun)(Type &))) nl()
       This constructor expects one argument: the address of a function to
        call from within its bf(operator()()) member. The function receives
        bf(FBB::Wrap1)bf(::operator()())'s argument as its argument. The
        template parameter type tt(Type) is the data type to which iterators
        (as specified in, e.g., bf(std::for_each())) eventually point.
    itb(Wrap1<Type [, Returntype = void]>(ReturnType (*fun)(Type const &)))nl()
       This constructor is identical to the first constructor, except for the
        actual tt(Type) parameter that's passed to the function, which is now
        a tt(Type const &).
    itb(Wrap1<Type [, Returntype = void]>(ReturnType (*fun)(Type *))) nl()
       This constructor is identical to the first constructor, except for the
        actual tt(Type) parameter that's passed to the function, which is now
        a tt(Type *).
    itb(Wrap1<Type [, Returntype = void]>(ReturnType (*fun)(Type const *)))nl()
       This constructor is identical to the first constructor, except for the
        actual tt(Type) parameter that's passed to the function, which is now
        a tt(Type const *).
    )

manpagesection(OVERLOADED OPERATORS)

    In normal situations the following member functions will call the function
that is passed to bf(FBB::Wrap1)'s constructor. See the example below.

    itemization(
    itb(ReturnType operator()(Type &param) const)
        This function is called by the generic algorithms, receiving the
dereferenced iterator that is managed  by the generic algorithm as its
argument (so, the iterator points to modifiable tt(Type) objects). This
operator is used with the first constructor.
    itb(ReturnType operator()(Type const &param) const)
        This function is called by the generic algorithms, receiving the
dereferenced iterator that is managed  by the generic algorithm as its
argument (so, the iterator points to immutable tt(Type) objects). This
operator is used with the second constructor. 
    itb(ReturnType operator()(Type *param) const)
        This function is called by the generic algorithms, receiving the
dereferenced iterator that is managed by the generic algorithm as its argument
(so, the iterator points to pointers to modifiable tt(Type) objects). This
operator is used with the third constructor.
    itb(ReturnType operator()(Type const *param) const)
        This function is called by the generic algorithms, receiving the
dereferenced iterator that is managed by the generic algorithm as its argument
(so, the iterator points to pointers to immutable tt(Type) objects). This
operator is used with the fourth constructor.
    )

manpagesection(TYPEDEFS)

    The class defines two types, which are used by generic algorithms:
    itemization(
    itb(argument_type), a synonym for bf(Type);
    itb(result_type), a synonym for bf(ReturnType).
    )

manpagesection(EXAMPLES)
        verb(
    #include <algorithm>
    #include <iostream>
    #include <vector>
    #include <string>   
    #include <bobcat/wrap1>
    
    using namespace std;
    using namespace FBB;
    
    bool cmp(string &actual)    // modifies `actual'
    {
        cout << "Saw " << actual << endl;
        bool ret = actual == "hello";
        actual += ".";
        return ret;
    }
    
    class X
    {
        public:
                                // merely inspects `actual'
            static bool cmp(string const &actual)
            {
                cout << "Saw " << actual << endl;
                return actual == "hello";
            }
    };
    
    int main(int argc, char **argv)
    {
        vector<string> vs(argv, argv + argc);
    
        find_if(vs.begin(), vs.end(), 
            Wrap1<string, bool>(&cmp));
    
        cout << endl;
    
        find_if(vs.begin(), vs.end(), 
            Wrap1<string, bool>(&X::cmp));
    
    }
        )

manpagefiles()
    em(bobcat/wrap1) - defines the class interface

manpageseealso()
    bf(bobcat)(7), bf(wrap1c)(3bobcat), bf(wrap2)(3bobcat), 
    bf(wrap2c)(3bobcat)

manpagebugs()
    None Reported.

includefile(trailer.inc)
