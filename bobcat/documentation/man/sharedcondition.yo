includefile(include/header)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(FBB::SharedCondition)(3bobcat)(_CurYrs_)
        (libbobcat-dev__CurVers_-x.tar.gz)(Shared Memory Cond. Var.)

manpagename(FBB::SharedCondition)(Shared Memory Condition Variable)

manpagesynopsis()
    bf(#include <bobcat/sharedcondition>)nl()
    Linking option: tt(-lpthread, -lbobcat ) 

manpagedescription()

    Condition variables are used to synchronize threads based on the values of
data. Condition variables allow threads to wait until a certain condition has
occurred, after which the threads continue their actions. Thus waiting threads
don't continuously have to poll the state of a variable (requiring the threads
to gain access to the variable before they can inspect its value). Using
condition variables waiting threads simply wait until they are notified.

    bf(SharedCondition) objects can be used in combination with shared
memory. The bf(SharedCondition) object is defined in shared memory and may be
accessed by threads running in different processes. These different
processes might run a single tt(main) thread, or they themselves can be
multi-threaded.

    Condition variables are encountered in situations like these:
    itemization(
    it() There exists a thread which should be suspended until a certain
        condition has been met. 
    it() This thread locks a mutex (or waits until the lock has been obtained)
    it() While the condition hasn't been met, the thread is suspended (i.e.,
        waits), automatically releasing the mutex's lock. 
    it() Somehow (see below) the thread is resumed, at which point the thread
        has automatically reacquired the lock.
    it() Once the condition has been met, the while loop ends, and the mutex's
        lock is released.
    it() There exists a second thread, which influences the variables that are
        elements of the condition, and which may notify the waiting thread,
        once the required condition has been met.
    it() This second thread locks the same mutex as used by the first thread.
    it() The second thread modifies the variables that are involved, and if
        the required condition has been met, it notifies the first thread.
    it() The second thread releases the mutex's lock, allowing the first
        thread to obtain the mutex's lock. 
    )

While the first thread is waiting, it is suspended. It may be resumed when it
receives a notification from another thread, but also for spurious
reasons. Therefore the first thread must verify that the condition has been
met after resuming its actions.

As condition variables are always used in combination with mutexes,
bf(SharedMutex) encapsulates the mutex-handling. The software using
bf(SharedCondition) objects doesn't have to handle the mutexes itself.

bf(SharedCondition) objects are used to synchronize actions by different
processes, using shared memory as their vehicle of
synchronization/communication. For this to work, the bf(SharedCondition)
object should have been defined in shared memory.  The example section
provides an illustration.

bf(SharedCondition) objects themselves are small objects, containing the
necessary information to access the actual shared memory condition variable
(living in some shared memory segment).

includefile(include/namespace)

manpagesection(INHERITS FROM)
    bf(SharedMutex)(3bobcat)

manpagesection(CONSTRUCTORS)
    itemization(
    itb(SharedCondition())
       The default constructor creates an empty stub which cannot yet be used
        (using it results in throwing an tt(FBB::Exception)). As the
        bf(SharedCondition) class supports assignment operators, these empty
        stubs can be (re)configured at any time after their construction.
    )
       (Default) copy and move constructors are available. 

       The class's destructor releases (if applicable) its lock on the shared
        condition variables mutex lock. The destructor takes no action if its
        object in fact is an empty stub.

manpagesection(OVERLOADED OPERATORS)

    The (default) overloaded move and copy assignment operators are available.

manpagesection(MEMBER FUNCTIONS)

    The offset of the tt(SharedMemory) object in which the bf(SharedCondition)
        object has been defined after calling any of the bf(SharedCondition)
        members is equal to the offset before calling these members.

    itemization(
    itb(void lock() const)
       When returning from this member, the current process has locked the
        bf(SharedCondition) object.

    itb(void unlock() const)
       The object's lock is released.

    itb(void notify() noexept)
       One of the threads waiting on the bf(SharedCondition) object will wake
        up. The thread calling tt(notify) should release its mutex lock
        shortly after this, allowing the notified thread to obtain the
        lock. The prototypical piece of pseudo code illustrating the use of
        tt(notify) therefore looks like this:
       verb(
    sharedCondition.lock();     // lock the mutex
    ...                         // operate on the condition's variables
    if (conditionWasMet)        // ready to notify
        sharedCondition.notify(); 
    sharedCondition.unlock();   // release the lock
       )
       As the tt(sharedCondition.lock ... sharedCondition.unlock) sequence
        itself may repeatedly be executed, the tt(unlock) member cannot be
        called from within tt(notify).

    itb(void notifyAll() noexept)
       Different from the plain tt(notify) member, this member wakes up all of
        the threads waiting on the bf(SharedCondition) object. However, after
        the current thread has released its mutex lock only one of these
        signaled threads will actually obtain the lock. The pseudo code for
        using tt(notifyAll) is identical to the pseudo code for using
        tt(notify) (but then calling tt(notifyAll), of course).

    itb(std::streamsize offset() const)
       The location of the shared condition variable (within the
        tt(SharedMemory) object) is returned.

    itb(void wait())
       Before calling tt(wait) the current thread should have obtained a lock
        on the bf(SharedCondition) object. When calling tt(wait) the running
        thread suspends its activities and waits until being notified. Once
        notified, it reacquires the lock and continues. Shortly after this the
        process should release its lock on the bf(SharedCondition) object.
        lock. The prototypical piece of pseudo code illustrating the use of
        tt(wait) therefore looks like this:
       verb(
    sharedCondition.lock();         // lock the mutex
    while (conditionWasNotYetMet)   // waiting required
        sharedCondition.wait(); 
    sharedCondition.unlock();       // release the lock
       )

    itb(void wait(Predicate pred))
       This member was implemented as a member template. tt(Predicate) either
        is a predicate function or a predicate function object (not expecting
        arguments). As long as tt(pred) is returning false, tt(wait()) (no
        arguments) is called. The function returns once tt(pred) has returned
        tt(true).

        The running thread should have obtained a lock on bf(SharedCondition)
        prior to calling this member, and should release the lock after this
        member has returned.

        The pseudo code for using tt(wait(pred)) is identical to the pseudo
        code for using tt(wait) (but then calling tt(wait(pred)), of course).

    itb(std::cv_status wait_for(std::chrono::duration<Type, Unit> 
        const &relTime))
       This member was implemented as a member template. tt(Type) defines the
        type of the variable holding the amount of time (usually tt(int64_t)),
        specified in time unit tt(Unit). Predefined tt(duration) types exist,
        like tt(std::chrono::seconds(4)), representing 4 seconds, or
        tt(std::chrono::milliseconds(30)), representing 30 milliseconds.

        The running thread should have obtained a lock on bf(SharedCondition)
        prior to calling this member, and should release the lock after this
        member has returned.

        This member acts like tt(wait), returning
        tt(std::cv_status::no_timeout) if a notification was received before
        tt(relTime) has passed. Otherwise tt(std::cv_status::timeout) is
        returned.

    itb(bool wait_for(std::chrono::duration<Type, Unit> 
        const &relTime, Predicate pred))
       This member was implemented as a member template. tt(Type) defines the
        type of the variable holding the amount of time (usually tt(int64_t)),
        specified in time unit tt(Unit). tt(Predicate) either is a predicate
        function or a predicate function object (not expecting arguments).

        The running thread should have obtained a lock on bf(SharedCondition)
        prior to calling this member, and should release the lock after this
        member has returned.

        As long as tt(pred) returns false, tt(wait_for(relTime))
        is called. If the latter function returns tt(std::cv_status::timeout),
        then tt(pred()) is called, and its return value is returned. Otherwise
        tt(true) is returned.

    itb(std::cv_status wait_until(std::chrono::time_point<Clock, Duration> 
        const &absTime))
       This member has been implemented as a member template. tt(Clock)
        defines the clock-type to use (usually tt(std::chrono::system_clock)),
        tt(Duration) is the type name of a duration type (as used with
        tt(wait_for)). E.g., to specify 5 seconds after the current time this
        member could be called like this:
       verb(
    std::chrono::system_clock::now() + std::chrono::seconds(5)
        )

        The running thread should have obtained a lock on bf(SharedCondition)
        prior to calling this member, and should release the lock after this
        member has returned.

        This member acts like tt(wait), returning
        tt(std::cv_status::no_timeout) if a notification was received before
        tt(absTime) has passed. Otherwise tt(std::cv_status::timeout) is
        returned.

    itb(bool wait_until(std::chrono::time_point<Clock, Duration> 
        const &absTime, Predicate pred))
       This member was implemented as a member template. tt(Clock) and
        tt(Duration) define identical types as mentioned at the previous
        member.  tt(Predicate) either is a predicate function or a predicate
        function object (not expecting arguments).

        The running thread should have obtained a lock on bf(SharedCondition)
        prior to calling this member, and should release the lock after this
        member has returned.

        As long as tt(pred()) returns false, tt(wait_until(absTime))
        is called. If the latter function returns tt(std::cv_status::timeout),
        then tt(pred()) is called, and its return value is returned. Otherwise
        tt(true) is returned.
    )

manpagesection(STATIC MEMBER FUNCTIONS)

    itemization(
    itb(SharedCondition &attach(SharedMemory &shmem,
                        std::ios::off_type offset = 0,
                        std::ios::seekdir origin = std::ios::beg))
       The tt(SharedCondition) object interfacing to the shared condition
        variable at the specified offset in the specified tt(SharedMemory)
        object is returned. If the requested offset is invalid (i.e., smaller
        than 0 or exceeding tt(maxOffset)) an tt(FBB::Exception) is thrown.

    itb(FBB::SharedCondition create(SharedMemory &shmem)) 
       A bf(SharedCondition) object is initialized at the current offset of
        the tt(SharedMemory) object referred to by tt(shmem), or at the first
        offset of the next physical shared data segment if there's too little
        room at the current offset to define a bf(SharedCondition) object. An
        tt(FBB::Exception) is thrown if there isn't enough memory available in
        the tt(SharedMemory) object to define a bf(SharedCondition).

        bf(SharedCondition) objects created by this member remember their
        position within the tt(SharedMemory) object, and actions performed by
        the created bf(SharedCondition) object do not alter the
        tt(SharedMemory) object's offset. This function returns a
        tt(SharedCondition::Location) object.

    itb(size_t size() const)
       Returns the size in bytes of shared condition variables stored in
        tt(SharedMemory) objects.
    )

manpagesection(EXAMPLE)
    
    verbinclude(../../sharedcondition/driver/driver.cc)


manpagefiles()
    em(bobcat/sharedcondition) - defines the class interface

manpageseealso()
    bf(bobcat)(7)
        bf(isharedstream)(3bobcat),
        bf(osharedstream)(3bobcat),
        bf(sharedblock)(3bobcat), 
        bf(sharedmemory)(3bobcat),
        bf(sharedpos)(3bobcat), 
        bf(sharedreadme)(7bobcat), 
        bf(sharedsegment)(3bobcat), 
        bf(sharedstream)(3bobcat), 
        bf(sharedstreambuf)(3bobcat)

manpagebugs()
    None Reported.

includefile(include/trailer)
