includefile(include/header)

COMMENT(replace 'sharedcondition' by the name of the new class)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(FBB::SharedCondition)(3bobcat)(_CurYrs_)
        (libbobcat-dev__CurVers_-x.tar.gz)(Shared Memory Cond. Var.)

manpagename(FBB::SharedCondition)(Shared Memory Condition Variable)

manpagesynopsis()
    bf(#include <bobcat/sharedcondition>)nl()
    Linking option: tt(-lpthread, -lbobcat ) 

manpagedescription()

    Condition variables are used to synchronize threads based on the values of
data. Condition variables allow threads to wait until a certain condition has
occurred, after which they continue their action. The advantage of using
condition variables is that the waiting thread doesn't continuously have to
poll the state of a variable (requiring the thread to gain access to the data
before the data's values can be inspected). Instead, the waiting thread simply
waits until it is notified by another thread that it can continue.

    bf(SharedCondition) objects can be used in combination with shared
memory. The bf(SharedCondition) object is defined in shared memory and may be
accessed by threads running in different processes. These different
processes might run a single tt(main) thread, or they themselves can be
multi-threaded.

    In most situations condition variables are used like this:
    itemization(
    it() There exists a thread which should be suspended until a certain
        condition has been met. 
    it() This thread locks a mutex (or waits until the lock has been obtained)
    it() While the condition hasn't been met, the thread is suspended (i.e.,
        waits), automatically releasing the mutex's lock. 
    it() Somehow (see below) the thread is resumed, at which point the thread
        has automatically reacquired the lock.
    it() Once the condition has been met, the while loop ends, and the mutex's
        lock is released.
    it() There exists a second thread, which influences the variables that are
        elements of the condition, and which may notify the waiting thread,
        once the required condition has been met.
    it() This second thread locks the same mutex as used by the first thread.
    it() The second thread modifies the variables that are involved, and if
        the required condition has been met, it notifies the first thread.
    it() The second thread releases the mutex's lock, allowing the first
        thread to obtain the mutex's lock. 
    )

While the first thread is waiting, it is suspended. It may be resumed when it
receives a notification from another thread, but also for spurious
reasons. Therefore the first thread must verify that the condition has been
met after resuming its actions.

As condition variables are always used in combination with mutexes,
bf(SharedMutex) encapsulates the mutex-handling. The software using
bf(SharedCondition) objects doesn't have to handle the mutexes itself.

bf(SharedCondition) objects are used to synchronize actions by different
processes, using shared memory as their vehicle of
synchronization/communication. The example section provides an illustration.


includefile(include/namespace)

manpagesection(INHERITS FROM)
    -

manpagesection(CONSTRUCTORS)
    itemization(
    itb(SharedCondition())
       The default constructor initializes an bf(FBB::SharedCondition) object to a
        shared memory mutex (using the tt(PTHREAD_PROCESS_SHARED)
        attribute). As an bf(FBB::SharedCondition) object will normally be defined
        inside a shared memory segment the object's memory is already
        available. In this case placement new should be used to call the
        constructor. E.g., if a shared memory segment is attached to the
        current process at tt(d_shared), and an bf(FBB::SharedCondition) should be
        defined at tt(d_shared)'s address, then the bf(FBB::SharedCondition)
        object can be initialized like this: 
       verb(
    new (d_shared) FBB::SharedCondition;
       )
    )
       The copy and move constructors are not available. 

       The class's destructor releasea all of the current process's nested
        shared memory segment locks. To destroy an bf(FBB::SharedMuted) object
        that has been constructed using the placement tt(new) operator use
       verb(
    d_sharedcondition->~SharedCondition();
       )
       (assuming tt(SharedCondition *d_sharedcondition) points to the location where
        placement new has previously initialized the bf(FBB::SharedCondition)
        object.) 

manpagesection(MEMBER FUNCTIONS)
    itemization(
    itb(void lock() const)
       When returning from this member, the current process has locked the
        shared memory segment.

    itb(void unlock() const)
       The object's lock of the shared memory segment is released.
    )

manpagesection(EXAMPLE)
    See the bf(sharedstream)(3bobcat) man page.


manpagefiles()
    em(bobcat/sharedcondition) - defines the class interface

manpageseealso()
    bf(bobcat)(7)
        bf(isharedstream)(3bobcat),
        bf(osharedstream)(3bobcat),
        bf(sharedblock)(3bobcat), 
        bf(sharedmemory)(3bobcat),
        bf(sharedpos)(3bobcat), 
        bf(sharedsegment)(3bobcat), 
        bf(sharedstream)(3bobcat), 
        bf(sharedstreambuf)(3bobcat)

manpagebugs()
    None Reported.

includefile(include/trailer)


