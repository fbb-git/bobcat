includefile(include/header)

COMMENT(replace 'sharedmemory' by the name of the new class)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(FBB::SharedMemory)(3bobcat)(_CurYrs_)(libbobcat-dev__CurVers_-x.tar.gz)
                    (Shared Memory Memory)

manpagename(FBB::SharedMemory)(Shared Memory memory structure)

manpagesynopsis()
    bf(#include <bobcat/sharedmemory>)nl()
    Linking option: tt(-lbobcat ) 

manpagedescription()

    The class bf(FBB::SharedMemory) implements a usable interface to a shared
memory segment made available by tt(FBB::SharedSegment) and monitored by
tt(FBB::SharedPos). It is the main building block for
tt(FBB::SharedStreambuf), defining the `device' to which
tt(FBB::SharedStreambuf) interfaces. All shared memory related I/O should be
performed through an bf(FBB::SharedMemory) object, which is a true object, not
itself residing in shared memory. An bf(FBB::SharedMemory) object defines,
connects to and manages access to shared memory, encapsulating all raw shared
memory operations. In addition to the class bf(FBB::SharedMemory) the header
file tt(bobcat/sharedmemory) also defines a bf(struct SharedEnum__) defining
an bf(enum SizeUnit). 

    Caveat: when constructing a shared memory segment make sure the segment's
ID is stored at a retrievable location. This allows other processes to access
the shared segment. The shared segment ID is also required to delete a shared
memory segment. If the shared segment ID is lost, the memory occupied by the
shared memory segment remains inaccessible, and will reduce the amount of
usable memory until the computer is rebooted. The member function tt(id)
returns the ID of the shared memory currently monitored by an
bf(FBB::SharedMemory) object.

includefile(include/namespace)

manpagesection(INHERITS FROM)
    bf(FBB::SharedEnum__)

    The bf(struct SharedEnum__) is a wrapper struct around bf(enum SizeUnit),
which is available through inheritance in several bf(FBB::Shared*) classes,
and offers symbolic constants defining standard memory sizes. The bf(enum
SizeUnit) defines the following symbolic constants:
        itemization(
        itb(kB), representing 2+sups(10) bytes of memory;
        itb(MB), representing 2+sups(20) bytes of memory;
        itb(GB), representing 2+sups(30) bytes of memory
        )

manpagesection(CONSTRUCTORS, DESTRUCTOR)

    itemization(
    itb(SharedMemory())
       The default constructor does not yet access a shared memory segment,
        but can be used to define a stub bf(FBB::SharedMemory) object, to be
        used at some later point during the execution of a program.

    itb(SharedMemory(size_t maxSize, SizeUnit sizeUnit, size_t access = 0600))
       This constructor creates a shared memory segment having a capacity of
        at least tt(maxSize * sizeUnit) bytes. The shared memory's access
        rights are defined by the tt(access) parameter, using the well-known
        (bf(chmod)(1)) way to define the access rights for the owner, the
        group and others. If construction succeeds the shared memory is
        ready for use. If construction fails, an tt(FBB::Exception) is
        thrown. 

    itb(SharedMemory(int id))
       This constructor connects to a shared memory segment having ID
        tt(id). If construction succeeds the shared memory is ready for
        use. If construction fails (e.g., no shared memory segment having ID
        tt(id) exists, an tt(FBB::Exception) is thrown.

    itb(~SharedMemory())
       The destructor detaches any attached shared memory segments from
        the bf(FBB::SharedMemory) object. If the shared memory segment is
        currently locked by the bf(FBB::SharedMemory) object, the lock is
        removed.
    )

    copy and move constructors are not available.

manpagesection(OVERLOADED OPERATORS)
    itemization(
    itb(std::ostream &operator<<(std::ostream &out, 
                                    SharedMemory const &sharedMemory))
       The overloaded insertion operator inserts information about the
        tt(SharedMemory) object into the provide tt(ostream) object. The IDs
        of the shared segments, their sizes, the maximum number of shared
        memory segments, the number of bytes that can be read from the shared
        memory, and its actual storage capacity, etc., are displayed.

    itb(SharedMemory &operator=(SharedMemory &&rhs))
       The overloaded move assignment operator is available. It is used to
        (re)define the shared memory segment an bf(FBB::SharedMemory) object
        is interfacing with.
    )

    The overloaded copy assignement operator is not available.

manpagesection(MEMBER FUNCTIONS)
    itemization(
    itb(void clear())
       First, the shared memory is locked. Next, all shared data segment are
        deleted, and the shared memory's own data are reset to indicate it is
        completely empty. Following this the shared memory segment is unlocked
        again. Returning from tt(clear) the shared memory The
        bf(FBB::SharedMemory) object is effectively re-initialized, with
        tt(offset) and tt(nReadable) returning 0.

    itb(int get())
       First the bf(FBB::SharedMemory) object calls tt(lock) to lock the
        shared memory segment. Next the character at tt(offset) is retrieved
        and tt(offset) is incremented. Then tt(unlock) is called, and the
        retrieved character is returned. If tt(offset) is at least equal to
        tt(nReadable, EOF) is immediately returned.

    itb(int id() const)
       The ID of the shared memory segment is returned.

    itb(void kill())
       Without locking the shared memory all shared memory controlled by the
        bf(FBB::SharedMemory) object is deleted. The bf(FBB::SharedMemory)
        object is unusable after returning from tt(kill).

    itb(std::streamsize maxOffset() const)
       The maximum possible offset that can be used with the shared memory
        segment is returned. The members tt(offset) and tt(nReadable)
        never exceed the value returned by tt(maxOffset).

    itb(std::streamsize nReadable() const)
       The number of characters (bytes) that can be read from the beginning of
        the shared memory is returned.
    
    itb(std::streamsize offset() const)
       The offset within the shared memory segment is returned.

    itb(char *ptr())
        Returns 0 if tt(offset() == maxOffset()). Otherwise it returns a
        pointer to the character at index tt(offset) within the shared memory
        segment.

    itb(int put(int ch))
       After locking the appropriate shared data segment, tt(ch) is written at
        position tt(offset), incrementing tt(offset) thereafter. If tt(ch ==
        EOF, EOF) is immediately returned.

    itb(int read(char *data, std::streamsize len))
       While locking the appropriate shared data segment(s) at most tt(len)
        bytes are read from the shared memory, starting at tt(offset). The
        bytes read from shared memory are stored at tt(data).  The number of
        bytes actually written is returned. This member returns -1 if
        initially tt(offset) was at least equal to tt(nReadable).
              
    itb(void remove())
       The shared memory is locked, after which all shared memory controlled
        by the bf(FBB::SharedMemory) object is deleted. The
        bf(FBB::SharedMemory) object is unusable after returning from
        tt(remove).

    itb(std::ios::pos_type seek(std::ios::off_type offset, 
                            std::ios::seekdir way = std::ios::beg))
       Moves the tt(offset) position relative to tt(way). The value -1 is
        returned when seeking before offset 0 or beyond tt(maxOffset).

    itb(std::streamsize showmanyc() const)
       The number of characters that can be read from the current shared
        segment data block is returned.  This member interrogates the number
        of readable characters in the shared memory segment. This number may
        change while this member is being executed. In order to receive a
        stable return value, calling functions should have obtained a lock on
        the shared memory segment before calling this member.

    itb(void swap(SharedMemory &other))
       The current and other bf(FBB::SharedMemory) objects are swapped.

    itb(bool try_lock() const)
       When returning tt(true) the current process has obtained the lock, and
        the object's lock count is set to 1. Otherwise, tt(false) is returned
        (which includes the case where the process already has obtained the
        lock).

    itb(void unlock() const)
       If the object's lock count is zero, the function immediately
        returns. Otherwise, the object's lock count is decremented. Once the
        lock count has decremented to zero the lock of the shared memory
        segment is released.

    itb(int write(char const *data, std::streamsize len))
       The bf(FBB::SharedMemory) object calls tt(lock) to lock the shared
        memory, and writes at most tt(len) bytes into the shared memory,
        starting at tt(offset). Next, tt(unlock) is called. The number of
        bytes actually written is returned. The member function returns -1 if
        initially tt(offset) is equal to tt(maxOffset).
    )

manpagesection(EXAMPLE)
    See the bf(sharedstream)(3bobcat) man page.

manpagefiles()
    em(bobcat/sharedmemory) - defines the class interface

manpageseealso()
    bf(bobcat)(7), bf(chmod)(1),
        bf(isharedstream)(3bobcat),
        bf(osharedstream)(3bobcat),
        bf(sharedsegment)(3bobcat),
        bf(sharedmutex)(3bobcat), 
        bf(sharedpos)(3bobcat), 
        bf(sharedstream)(3bobcat), 
        bf(sharedstreambuf)(3bobcat)

manpagebugs()
    None Reported.

includefile(include/trailer)


