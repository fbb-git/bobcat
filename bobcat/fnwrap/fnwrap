#ifndef INCLUDED_BOBCAT_FNWRAP_
#define INCLUDED_BOBCAT_FNWRAP_

#include <tuple>
#include <bobcat/typetrait>

namespace FBB
{

class FnWrap
{
    template <typename Function>
    struct Dissect
    {};
    template <typename Ret, typename ...Args>
    struct Dissect <Ret (*)(Args ...)>
    {
        typedef Ret ReturnType;
    };
    template <size_t size, typename Tuple>
    struct At
    {
        typedef typename std::tuple_element<size - 1, Tuple>::type Type;
    };

        // Generic definition: expand all tuple's arguments through
        // recursive calls
        //
    template <typename RetType, typename Func, 
                typename Arg1, typename Arg2, size_t size, 
                typename Tuple, typename ... Args>
    struct CallPack: public CallPack<
                        RetType, Arg1, Arg2, Func, size - 1, Tuple, 
                        typename At<size, Tuple>::Type, Args ...>
    {
        typedef typename TypeTrait<Arg1>::Plain first_argument_type;
        typedef typename TypeTrait<Arg2>::Plain second_argument_type;

        static RetType
            call(Func fun, Arg1 &&arg1, Arg2 &&arg2, Tuple &&tuple, 
                                                        Args &&...args)
            {
                return 
                    CallPack<
                        RetType, Func, Arg1, Arg2, size - 1, Tuple, 
                        typename std::tuple_element<size - 1, Tuple>::type, 
                        Args ...
                    >::call(
                        fun, 
                        std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), 
                        tuple, 
                        std::forward<typename At<size, Tuple>::Type>
                                    (std::get<size - 1>(tuple)), 
                        std::forward<Args>(args) ...
                    );
            }
    };

        // Final definition with a non-void return type: call the 
        // unary function
    template <typename RetType, typename Func, typename Arg1,
                typename Tuple, typename ... Args>
    struct CallPack<RetType, Func, Arg1, Dissect<int> *, 0, Tuple, Args...>
    {
        static RetType call(Func fun, Arg1 &&arg1, Dissect<int> *&&arg2, 
                                                Tuple &&tuple, Args &&...args)
        {
            return fun(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
        }
    };

        // Final definition with a non-void return type: call the 
        // binary function
    template <typename RetType, typename Func, typename Arg1, typename Arg2,
                typename Tuple, typename ... Args>
    struct CallPack<RetType, Func, Arg1, Arg2, 0, Tuple, Args...>
    {
        static RetType call(Func fun, Arg1 &&arg1, Arg2 &&arg2, 
                                                Tuple &&tuple, Args &&...args)
        {
            return fun(std::forward<Arg1>(arg1), std::forward<Arg1>(arg1), 
                       std::forward<Args>(args)...);
        }
    };

        // Final definition with a void return type: call the 
        // unary function. The Dissect<int> * type is private to FnWrap and
        // cannot be passed by using software
    template <typename Func, typename Arg1, typename Tuple, typename ... Args>
    struct CallPack<void, Func, Arg1, Dissect<int> *, 0, Tuple, Args...>
    {
        static void call(Func fun, Arg1 &&arg1, Dissect<int> *&&arg2, 
                                            Tuple &&tuple, Args &&...args)
        {
            fun(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
        }
    };

        // Final definition with a void return type: call the 
        // binary function
    template <typename Func, typename Arg1, typename Arg2, typename Tuple, 
                                                            typename ... Args>
    struct CallPack<void, Func, Arg1, Arg2, 0, Tuple, Args...>
    {
        static void call(Func fun, Arg1 &&arg1, Arg2 &&arg2, 
                                            Tuple &&tuple, Args &&...args)
        {
            fun(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), 
                                          std::forward<Args>(args)...);
        }
    };

public:
    template <typename Function, typename ... Args>
    struct Functor
    {
        typedef typename Dissect<Function>::ReturnType RetType;

        Function d_function;
        std::tuple<Args ...> d_args;

        Functor(Function fun, Args &&... args)
        :
            d_function(fun),
            d_args(std::forward<Args>(args)...)
        {}

        template <typename Arg1, typename Arg2>
        typename Functor::RetType operator()(Arg1 &&arg1, Arg2 &&arg2)
        {
            return CallPack<RetType, Function, Arg1, Arg2, sizeof ... (Args),
                            std::tuple<Args ...>>::call(d_function, 
                                                    std::forward<Arg1>(arg1),
                                                    std::forward<Arg2>(arg2),
                                                    d_args);
        }

        template <typename Arg1>
        typename Functor::RetType operator()(Arg1 &&arg1)
        {
            return CallPack<RetType, Function, Arg1, Dissect<int>*,
                            sizeof ... (Args),
                            std::tuple<Args ...>
                    >::call(d_function, std::forward<Arg1>(arg1), 0, d_args);
        }
    };

    template <typename Function, typename ... Args>
    static Functor<Function, Args...> unary(Function fun, Args &&...args)
    {
        return Functor<Function, Args...>(fun, std::forward<Args>(args) ...);
    }
    template <typename Function, typename ... Args>
    static Functor<Function, Args...> binary(Function fun, Args &&...args)
    {
        return unary(fun, std::forward<Args>(args) ...);
    }
};    

template <typename Function, typename ... Args>
FnWrap::Functor<Function, Args...> context(Function fun, Args &&...args)
{
    return FnWrap::Functor<Function, Args...>
                          (fun, std::forward<Args>(args) ...);
}

}   // namespace FBB

#endif
