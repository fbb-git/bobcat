#ifndef INCLUDED_BOBCAT_BINOPS_
#define INCLUDED_BOBCAT_BINOPS_

#include <utility>

// The templates in this file were not defined in the namespace FBB to enhance
// their usability. If you want to declare them in a namespace of your own
// include them in your namespace-block, like this:
//  namespace YOUR_NAMESPACE
//  {
//      #include <bobcat/binops>
//  }

template <typename Class>
inline Class operator+(Class &&lhs, Class const &rhs)
{
    return lhs += rhs;
}

template <typename Class>
Class operator+(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator+(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator-(Class &&lhs, Class const &rhs)
{
    return lhs -= rhs;
}

template <typename Class>
Class operator-(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator-(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator*(Class &&lhs, Class const &rhs)
{
    return lhs *= rhs;
}

template <typename Class>
Class operator*(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator*(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator/(Class &&lhs, Class const &rhs)
{
    return lhs /= rhs;
}

template <typename Class>
Class operator/(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator/(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator%(Class &&lhs, Class const &rhs)
{
    return lhs %= rhs;
}

template <typename Class>
Class operator%(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator%(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator^(Class &&lhs, Class const &rhs)
{
    return lhs ^= rhs;
}

template <typename Class>
Class operator^(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator^(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator&(Class &&lhs, Class const &rhs)
{
    return lhs &= rhs;
}

template <typename Class>
Class operator&(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator&(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator|(Class &&lhs, Class const &rhs)
{
    return lhs |= rhs;
}

template <typename Class>
Class operator|(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator|(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator<<(Class &&lhs, Class const &rhs)
{
    return lhs <<= rhs;
}

template <typename Class>
Class operator<<(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator<<(std::move(tmp), rhs);
}

template <typename Class>
inline Class operator>>(Class &&lhs, Class const &rhs)
{
    return lhs >>= rhs;
}

template <typename Class>
Class operator>>(Class const &lhs, Class const &rhs)
{
    Class tmp(lhs);
    return operator>>(std::move(tmp), rhs);
}

#endif


