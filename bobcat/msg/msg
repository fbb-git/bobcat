#ifndef INCLUDED_BOBCAT_MSG_
#define INCLUDED_BOBCAT_MSG_

#include <iterator>

#include <sstream>
#include <fstream>
#include <string>
#include <algorithm>

#include <bobcat/errno>
#include <bobcat/msgstream>

namespace FBB
{

extern MsgStream emsg;
extern MsgStream imsg;
extern MsgStream fmsg;
extern MsgStream wmsg;

void info(std::ostream &out);               // DEPRECATED
void spool(std::ostream &out);              // DEPRECATED
void warning(std::ostream &out);            // DEPRECATED
void err(std::ostream &out);                // DEPRECATED
void fatal(std::ostream &out);              // DEPRECATED
std::ostringstream &msg();                  // DEPRECATED
std::ostringstream &lineMsg();              // DEPRECATED

class Msg
{
    friend class MsgStream;
    static MsgStream *s_msgStream[];

    public:
        enum Type       // update s_sizofType below if this changes
        {
            ERROR,
            FATAL,
            INFO,
            WARNING
        };

    private:
        static size_t const s_sizeofType = WARNING + 1;

    public:
        static bool display();                  // true if >= 1 type is active
        static bool display(Type type);         // true if type is active

        static bool setDisplay(bool mode);      // 1, all types on/off 

                                                // a particular type on/off
        static void setDisplay(Type type, bool mode);   // inline

//=============
                                                // a particular type uses
                                                // a particular output dev.
        static void setDisplay(Type type, std::string const &name); // 3
        static void setDisplay(Type type, std::streambuf *buffer);  // 4
        static void setDisplay(Type type, std::ostream &stream);    // 5
                                                
        template <typename Device>              // all types use the same
        static void setDisplay(Device &device); // output device

        static std::streambuf *msgbuf(Type type);

        static void open(std::ifstream &in, std::string const &name);
        static void open(std::ifstream &in, std::string const &name, 
                                                std::ios::openmode mode);
        static void open(std::ofstream &out, std::string const &name);
        static void open(std::ofstream &out, std::string const &name,
                                                std::ios::openmode mode);
        static void open(std::ofstream &out, std::string const &name, 
                                                size_t protection);
        static void open(std::ofstream &out, std::string const &name, 
                                                size_t protection,
                                                std::ios::openmode mode);
        static void open(std::fstream &out, std::string const &name,
                                                std::ios::openmode mode);

    private:
        static void prepareStream(MsgStream *ms);
        static bool isActive(MsgStream const *ms);
        static void setActive(MsgStream *ms, bool active);
        static void activateStream(MsgStream *si);
        static void suppressStream(MsgStream *si);


     // ALL MEMBERS AND FUNCTIONS DECLARED AS FRIEND BELOW THIS LINE 
     // ARE DEPRECATED

    public: 
        static void setOstream(std::string const &name);
        static std::streambuf *setInfoBuf(
                        std::streambuf *newBuffer, bool display = true);
        static void setLine(size_t linenr);
        static void setWarning(char const *pre = "[Warning] ");
        static void setMaxCount(size_t maxCount);
        static size_t count();
        static bool errors();
        static size_t warnings();
        static std::streambuf *infoToWarning();

    private:
        friend void err(std::ostream &out);
        friend void spool(std::ostream &out);
        friend void info(std::ostream &out);
        friend void warning(std::ostream &out);
        friend void fatal(std::ostream &out);
    
        friend std::ostringstream &msg();
        friend std::ostringstream &msgstream();
        friend std::ostringstream &lineMsg();
    
        static std::ostringstream s_msg;
};


inline bool Msg::isActive(MsgStream const *ms)
{
    return ms->good();
}

inline bool Msg::display()
{
    return std::count_if(s_msgStream, s_msgStream + s_sizeofType, isActive);
}

inline bool Msg::display(Type type)
{
    return s_msgStream[type]->good();
}
 
inline void Msg::setDisplay(Type type, bool mode)
{
    setActive(s_msgStream[type], mode);
}
 
inline std::streambuf *Msg::msgbuf(Type type)
{
    return s_msgStream[type]->msgbuf();
}

inline void Msg::setLine(size_t linenr)
{
    imsg.setLineNr(linenr);
}            

inline void Msg::setWarning(char const *pre)
{
    wmsg.setTag(pre);
}

inline void Msg::setMaxCount(size_t maxCount)
{
    emsg.setMaxCount(maxCount);
}

inline size_t Msg::count()
{
    return emsg.count();
}

inline bool Msg::errors()
{
    return emsg.count();
}

inline size_t Msg::warnings()
{
    return wmsg.count();
}

inline std::ostringstream &msgstream()
{
    return Msg::s_msg;
}

template <typename Device>
void Msg::setDisplay(Device &device)
{
    setDisplay(INFO, device);
    for (size_t idx = WARNING; idx != s_sizeofType; ++idx)
        setDisplay(static_cast<Type>(idx), msgbuf(INFO));
}

inline void operator<<(std::ostream &ostr, void (*manip)(std::ostream &))
{
    (*manip)(ostr);
}

}   // namespace FBB

#endif



