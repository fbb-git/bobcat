#ifndef INCLUDED_BOBCAT_MSG_
#define INCLUDED_BOBCAT_MSG_

#include <iterator>

#include <sstream>
#include <fstream>
#include <string>
#include <algorithm>

#include <bobcat/errno>

namespace FBB
{

void info(std::ostream &out);
void spool(std::ostream &out);
void warning(std::ostream &out);
void err(std::ostream &out);
void fatal(std::ostream &out);

std::ostringstream &msg();
std::ostringstream &lineMsg();

class Msg
{
    friend void err(std::ostream &out);
    friend void spool(std::ostream &out);
    friend void info(std::ostream &out);
    friend void warning(std::ostream &out);
    friend void fatal(std::ostream &out);

    friend std::ostringstream &msg();
    friend std::ostringstream &msgstream();
    friend std::ostringstream &lineMsg();

    static size_t s_line;    
    static char const *s_warning;
    static size_t s_warnCount;
    static size_t s_count;
    static size_t s_maxCount;
    static std::ostringstream s_msg;
    static bool s_display;

    struct StreamInfo
    {
        std::ostream out;
        std::ofstream fout;

        StreamInfo();
    };

    static StreamInfo s_streams[];
    static size_t const s_nStreams;

    public:
        enum Type
        {
            INFO,
            WARNING,
            ERROR,
            FATAL
        };
    private:
        static size_t const s_sizeofType = FATAL + 1;

    public:
        static bool display();                  // true if >= 1 type is active
        static bool display(Type type);         // true if type is active

        static bool setDisplay(bool mode);      // all types on/off

                                                // a particular type on/off
        static void setDisplay(Type type, bool mode);   // inline

                                                // a particular type uses
                                                // a particular output dev.
        static void setDisplay(Type type, std::string const &name); // 3
        static void setDisplay(Type type, std::streambuf *buffer);  // 4
        static void setDisplay(Type type, std::ostream &stream);    // 5

                                                // all types use the same
                                                // output device
        template <typename Device>
        static void setDisplay(Device &device);

        static std::streambuf *sbuf(Type type);

        static void open(std::ifstream &in, std::string const &name);
        static void open(std::ifstream &in, std::string const &name, 
                                                std::ios::openmode mode);
        static void open(std::ofstream &out, std::string const &name);
        static void open(std::ofstream &out, std::string const &name,
                                                std::ios::openmode mode);
        static void open(std::ofstream &out, std::string const &name, 
                                                size_t protection);
        static void open(std::ofstream &out, std::string const &name, 
                                                size_t protection,
                                                std::ios::openmode mode);
        static void open(std::fstream &out, std::string const &name,
                                                std::ios::openmode mode);

        static void setOstream(std::string const &name);    // DEPRECATED
        static std::streambuf *setInfoBuf(                  // DEPRECATED
                        std::streambuf *newBuffer, bool display = true);

        static void setLine(size_t linenr);
        static void setWarning(char const *pre = "[Warning] ");
        static void setMaxCount(size_t maxCount);

        static size_t count();
        static bool errors();
        static size_t warnings();


        static std::streambuf *infoToWarning();             // DEPRECATED

    private:
        static void prepareStream(StreamInfo &si);
        static void setActive(StreamInfo &si, bool active);
        static void activateStream(StreamInfo &si);
        static void suppressStream(StreamInfo &si);
        static bool isActive(StreamInfo const &si);

};


inline bool Msg::isActive(StreamInfo const &si)
{
    return si.out.good();
}

inline bool Msg::display()
{
    return std::count_if(s_streams, s_streams + s_sizeofType, isActive);
}

inline bool Msg::display(Type type)
{
    return s_streams[type].out.good();
}

inline void Msg::setDisplay(Type type, bool mode)
{
    setActive(s_streams[type], mode);
}

inline std::streambuf *Msg::sbuf(Type type)
{
    return s_streams[type].out.good() ? s_streams[type].out.rdbuf() : 0;
}

inline void Msg::setLine(size_t linenr)
{
    s_line = linenr;
}            

inline void Msg::setWarning(char const *pre)
{
    s_warning = pre;
}

inline void Msg::setMaxCount(size_t maxCount)
{
    s_maxCount = maxCount;
}
inline size_t Msg::count()
{
    return s_count;
}

inline bool Msg::errors()
{
    return s_count;
}

inline size_t Msg::warnings()
{
    return s_warnCount;
}

inline std::ostringstream &msgstream()
{
    return Msg::s_msg;
}

inline Msg::StreamInfo::StreamInfo()
:
    out(std::cout.rdbuf())
{}

template <typename Device>
void Msg::setDisplay(Device &device)
{
    setDisplay(INFO, device);
    for (size_t idx = WARNING; idx != s_sizeofType; ++idx)
        setDisplay(static_cast<Type>(idx), sbuf(INFO));
}

inline void operator<<(std::ostream &ostr, void (*manip)(std::ostream &))
{
    (*manip)(ostr);
}

}   // namespace FBB

#endif



