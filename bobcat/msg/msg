#ifndef INCLUDED_BOBCAT_MSG_
#define INCLUDED_BOBCAT_MSG_

#include <iterator>

#include <sstream>
#include <fstream>
#include <string>
#include <algorithm>

#include <bobcat/errno>

namespace FBB
{

void info(std::ostream &out);
void spool(std::ostream &out);
void warning(std::ostream &out);
void err(std::ostream &out);
void fatal(std::ostream &out);

std::ostringstream &msg();
std::ostringstream &lineMsg();

class Msg
{
    friend void err(std::ostream &out);
    friend void spool(std::ostream &out);
    friend void info(std::ostream &out);
    friend void warning(std::ostream &out);
    friend void fatal(std::ostream &out);

    friend std::ostringstream &msg();
    friend std::ostringstream &msgstream();
    friend std::ostringstream &lineMsg();

    static size_t s_line;    
    static char const *s_warning;
    static size_t s_warnCount;
    static size_t s_count;
    static size_t s_maxCount;
    static std::ostringstream s_msg;
    static std::ostream s_out;
    static std::ostream s_info;
    static std::ofstream s_fout;
    static bool s_display;

    struct StreamInfo
    {
        std::ostream out;
        std::ofstream fout;
        StreamInfo()
        :
            out(std::cout.rdbuf())
        {}
    };

    static StreamInfo s_streams[];
    static size_t const s_nStreams;

    public:
        enum Type
        {
            INFO,
            WARNING,
            ERROR,
            FATAL
        };
    private:
        static size_t const s_sizeofType = FATAL + 1;

    public:
        static bool display();
        static bool display(Type type);

        static bool setDisplay(bool mode);
        static bool setDisplay(Type type, bool mode);

        static void setDisplay(Type type, std::string const &name);
        static void setDisplay(Type type, std::streambuf *buffer);
        static void setDisplay(Type type, std::ostream &stream);
        static std::streambuf *sbuf(Type type);

        static void open(std::ifstream &in, std::string const &name);
        static void open(std::ifstream &in, std::string const &name, 
                                                std::ios::openmode mode);
        static void open(std::ofstream &out, std::string const &name);
        static void open(std::ofstream &out, std::string const &name,
                                                std::ios::openmode mode);
        static void open(std::ofstream &out, std::string const &name, 
                                                size_t protection);

        static void setOstream(std::string const &name);    // DEPRECATED
        static std::streambuf *setInfoBuf(                  // DEPRECATED
                        std::streambuf *newBuffer, bool display = true);

        static void setLine(size_t linenr);
        static void setWarning(char const *pre = "[Warning] ");
        static void setMaxCount(size_t maxCount);

        static size_t count();
        static bool errors();
        static size_t warnings();


        static std::streambuf *infoToWarning();             // DEPRECATED

    private:
        static void prepareStream(StreamInfo &si);
        static bool setActive(StreamInfo &si, bool active);
        static void activateStream(StreamInfo &si);
        static void suppressStream(StreamInfo &si);
        static bool isActive(StreamInfo const &si);

};


inline bool Msg::isActive(StreamInfo const &si)
{
    return si.out.good();
}

inline bool Msg::display()
{
    return std::count_if(s_streams, s_streams + s_sizeofType, isActive);
}

inline bool Msg::display(Type type)
{
    return s_streams[type].out.good();
}

inline bool Msg::setDisplay(Type type, bool mode)
{
    return setActive(s_streams[type], mode);
}

inline std::streambuf *Msg::sbuf(Type type)
{
    return s_streams[type].out.rdbuf();
}

inline void Msg::setLine(size_t linenr)
{
    s_line = linenr;
}            

inline void Msg::setWarning(char const *pre)
{
    s_warning = pre;
}

inline void Msg::setMaxCount(size_t maxCount)
{
    s_maxCount = maxCount;
}
inline size_t Msg::count()
{
    return s_count;
}

inline bool Msg::errors()
{
    return s_count;
}

inline size_t Msg::warnings()
{
    return s_warnCount;
}

inline std::streambuf *Msg::infoToWarning()
{
    return setInfoBuf(s_out.rdbuf());
}

inline std::ostringstream &msgstream()
{
    return Msg::s_msg;
}

inline void operator<<(std::ostream &ostr, void (*manip)(std::ostream &))
{
    (*manip)(ostr);
}

}   // namespace FBB

#endif



