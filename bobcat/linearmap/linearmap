#ifndef INCLUDED_BOBCAT_LINEARMAP_
#define INCLUDED_BOBCAT_LINEARMAP_

#include <vector>
#include <algorithm>

namespace FBB
{

template <
    typename Key, typename Value, 
    typename Alloc = std::allocator< std::pair<Key const, Value> >
>
class LinearMap: private std::vector<std::pair<Key, Value>, Alloc>
{
        typedef std::vector<std::pair<Key, Value>, Alloc>   Base;
        typedef LinearMap<Key, Value, Alloc>                LinMap;
        typedef std::pair<
            typename LinearMap<Key, Value, Alloc>::const_iterator,
            typename LinearMap<Key, Value, Alloc>::const_iterator
        >                                                   ConstIterPair;
        typedef std::pair<
            typename LinearMap<Key, Value, Alloc>::iterator,
            typename LinearMap<Key, Value, Alloc>::iterator
        >                                                   IterPair;

    public:
        typedef std::pair<Key, Value>           value_type;
        typedef typename Base::iterator         iterator;
        typedef typename Base::const_iterator   const_iterator;

        LinearMap()                     = default;
        LinearMap(LinMap const &other)  = default;
        LinearMap(LinMap &&tmp)         = default;

        template <typename Iterator>
        LinearMap(Iterator begin, Iterator end);

        LinMap &operator=(LinMap const &other)  = default;
        LinMap &operator=(LinMap &&tmp)         = default;

        Value &operator[](Key const &key);

        using Base::at;
        using Base::begin;
        using Base::capacity;
        using Base::cbegin;
        using Base::cend;
        using Base::clear;

        size_t count(Key const &key) const;

        using Base::emplace;
        using Base::empty;
        using Base::end;

        IterPair        equal_range(Key const &key);
        ConstIterPair   equal_range(Key const &key) const;

        using Base::erase;

        iterator find(Key const &key);
        const_iterator find(Key const &key) const;

        using Base::get_allocator;
        using Base::insert;

        iterator lower_bound(Key const &key);
        const_iterator lower_bound(Key const &key) const;

        using Base::max_size;
        using Base::rbegin;
        using Base::rend;
        using Base::reserve;
        using Base::size;
        using Base::swap;

        iterator upper_bound(Key const &key);
        const_iterator upper_bound(Key const &key) const;

    private:
        value_type *findPtr(Key const &key) const;
};

#include "count.f"
#include "equalrange1.f"
#include "find1.f"
#include "find2.f"
#include "findptr.f"
#include "linearmap1.f"
#include "lowerbound1.f"
#include "lowerbound2.f"
#include "operatorindex.f"
#include "upperbound1.f"
#include "upperbound2.f"

} // FBB        
#endif
