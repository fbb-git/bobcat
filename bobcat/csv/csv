#ifndef INCLUDED_BOBCAT_CSV_
#define INCLUDED_BOBCAT_CSV_

#include <iosfwd>
#include <vector>
#include <string>
#include <type_traits>
#include <iterator>

#include <bobcat/exception>

namespace FBB
{

    namespace IUO
    {
        template <typename Type>
        struct IsString
        {
            enum { cond = false };
        };
        
        template <>
        struct IsString<std::string>
        {
            enum { cond = false };
        };
    };

struct CSV
{
    enum Mode
    {
        EMPTY           = 0,
        TRAILINGCOMMA   = 1,
        LINE            = 2
    };

    private:
        std::vector<std::string> d_field;
        std::vector<bool>        d_available;
        std::string              d_type;
        Mode                     d_mode = EMPTY;

    public:
        CSV() = default;
        explicit CSV(std::string const &spec, Mode mode = LINE);
        
        size_t size() const;
        size_t count() const;

        template <typename Type>
        typename std::conditional<
                    IUO::IsString<Type>::cond, 
                    std::string const &, 
                    Type
                >::type get(size_t idx) const;

        template <typename Type>
        typename std::conditional<
                    IUO::IsString<Type>::cond, 
                    std::string const &, 
                    Type
                >::type available(size_t idx) const;

        std::string const &operator[](size_t idx) const;

        std::vector<std::string> const &data() const;
        std::vector<bool> const &available() const;

        template <typename Type>
        class const_iterator;

        template <typename Type>
        class const_reverse_iterator: public 
            std::reverse_iterator<const_iterator<Type>>
        {};

        template <typename Type>
        class const_iterator: public
                std::iterator<std::bidirectional_iterator_tag, 
                                typename std::conditional<
                                    IUO::IsString<Type>::cond, 
                                    std::string const &, 
                                    Type
                                >::type>
        {
            typedef std::vector<std::string>::const_iterator DataIter;
            DataIter d_iter;

            const_iterator() = default;

            const_iterator<Type> &operator++();
            const_iterator<Type> operator++(int);

            bool operator==(const_iterator<Type> const &other) const;
            bool operator!=(const_iterator<Type> const &other) const;

            std::pair<bool, typename std::conditional<
                                    IUO::IsString<Type>::cond, 
                                    std::string const &, 
                                    Type
                                >::type> operator*() const;

            Type *operator->() const;

            private:
                friend class CSV;
                friend class const_reverse_iterator<Type>;

                const_iterator(DataIter const &iter);
                const_iterator<Type> &operator--();
        };

        template <typename Type = std::string>
        const_iterator<Type> begin() const;


    private:
        void assign(size_t idx, std::string &element);

        friend std::istream &operator>>(std::istream &in, CSV &csv);
        std::istream &extract(std::istream &in);

};

inline std::vector<std::string> const &CSV::data() const
{
    return d_field;
}

inline std::vector<bool> const &CSV::available() const
{
    return d_available;
}

inline std::string const &CSV::operator[](size_t idx) const
{
    return d_field[idx];
}

template <typename Type>
inline  typename std::conditional<
                    IUO::IsString<Type>::cond, 
                    std::string const &, 
                    Type
                >::type CSV::available(size_t idx) const
{
    return static_cast<Type>(stoll(d_field[idx]));
}

template <>
typename std::conditional<
                    IUO::IsString<std::string>::cond, 
                    std::string const &, 
                    std::string
                >::type CSV::available<std::string>(size_t idx) const
{
    if (not d_available[idx])
        throw Exception() << "Field " << idx << " not available";

    return d_field[idx];
}

template <typename Type>
typename std::conditional<
                    IUO::IsString<Type>::cond, 
                    std::string const &, 
                    Type
                >::type CSV::get(size_t idx) const
{
    try
    {
        return available<Type>(idx);
    }
    catch (...)
    {
        return Type();
    }
}

template <>
inline  typename std::conditional<
                    IUO::IsString<std::string>::cond, 
                    std::string const &, 
                    std::string
                >::type CSV::get<std::string>(size_t idx) const
{
    return d_field[idx];
}

inline CSV::Mode operator|(CSV::Mode lhs, CSV::Mode rhs)
{
    return static_cast<CSV::Mode>(lhs | rhs);
}

inline size_t CSV::size() const
{
    return d_type.length();
}

inline std::istream &operator>>(std::istream &in, CSV &csv)
{
    return csv.extract(in);
}

template <typename Type>
CSV::const_iterator<Type> &CSV::const_iterator<Type>::operator++()
{
    ++d_iter;
    return *this;
}

template <typename Type>
CSV::const_iterator<Type> CSV::const_iterator<Type>::operator++(int)
{
    const_iterator<Type> ret(*this);
    ++d_iter;
    return ret;
}

template <typename Type>
inline bool CSV::const_iterator<Type>::operator!=(
                                const_iterator<Type> const &other) const
{
    return d_iter != other.d_iter;
}

template <typename Type>
inline bool CSV::const_iterator<Type>::operator==(
                                const_iterator<Type> const &other) const
{
    return d_iter == other.d_iter;
}

template <typename Type>
std::pair<bool, 
          typename std::conditional<
                        IUO::IsString<Type>::cond, 
                        std::string const &, 
                        Type
                   >::type
        >  CSV::const_iterator<Type>::operator*() const
{
    std::pair<bool, Type> ret(false, Type());

    try
    {
        ret.second = static_cast<Type>(stoll(*d_iter));
        ret.first = true;
    }
    catch (...)
    {}
    return ret;
}

template <>
std::pair<bool, 
          typename std::conditional<
                        IUO::IsString<std::string>::cond, 
                        std::string const &, 
                        std::string
                   >::type
        >  CSV::const_iterator<std::string>::operator*() const
{
    std::string const &str = *d_iter;

    return std::pair<bool, std::string const &>(not str.empty(), str);
}

//{
//    return std::pair<bool, Type>(
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//
//============
//        template <typename Type>
//        class const_iterator: public
//                std::iterator<std::bidirectional_iterator_tag, 
//                                typename std::conditional<
//                                    IUO::IsString<Type>::cond, 
//                                    std::string const &, 
//                                    Type
//                                >::type>
//        {
//            typedef std::vector<std::string>::const_iterator DataIter;
//            DataIter d_iter;
//
//            const_iterator() = default;
//
//            const_iterator<Type> &operator++();
//            const_iterator<Type> operator--(int);
//
//            bool operator==(const_iterator<Type> const &other) const;
//            bool operator!=(const_iterator<Type> const &other) const;
//
//            std::pair<bool, Type> operator*() const;
//            Type *operator->() const;
//
//            private:
//                friend class CSV;
//                friend class const_reverse_iterator<Type>;
//
//                const_iterator(DataIter const &iter);
//                const_iterator<Type> &operator--();
//        };
//
//        template <typename Type = std::string>
//        const_iterator<Type> begin() const;
//


} // FBB        
#endif





