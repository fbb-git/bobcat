#ifndef INCLUDED_BOBCAT_MSGSTREAM_
#define INCLUDED_BOBCAT_MSGSTREAM_

#include <climits>
#include <ostream>
#include <fstream>

#include <bobcat/msgbuf>

namespace FBB
{
    std::ostream &endm(std::ostream &os);

    // MsgStream cannot be an ostream as ostreams catch exceptions thrown from
    // them and transform them into an error state Cf.:
    // http://www.drdobbs.com/184401357:  
    //      A slightly more serious concern is that the virtual functions in a
    //      class that's derived from streambuf might throw exceptions;
    //      perhaps, for example, a user-defined class for network I/O might
    //      throw an exception when the underlying connection has been
    //      lost. High-level istream and ostream functions will catch those
    //      exceptions and translate them into an error state within the
    //      stream (that’s one of the reasons that seemingly innocent
    //      functions like istream::get are so complicated), but if you’re
    //      working with stream buffers directly there’s nobody to catch
    //      exceptions for you. If you work with stream buffers, you should
    //      make sure that your code is exception safe.
    // So MsgStream uses its own ostream to handle the outgoing messages and
    // after that tests the stream's state. If not good() and if d_throwing is
    // true then MsgStream throws the exception. The ostream itself is cleared
    // at a not good() anyway.
    //
class MsgStream: private BOBCAT::Msgbuf, public std::ostream
{
    friend std::ostream &endm(std::ostream &os);

    typedef BOBCAT::Msgbuf Msgbuf;

    std::ofstream d_ofstream;

    public:
        MsgStream(std::ostream *ostr, size_t maxCount, 
                     std::string const &tag = "", bool throwing = false);

        // The state-modifying members should not be used as they target
        // Msgbuf 
        
        // rdbuf members are still available but will usually result in 
        // unexpected behavior as they return/change Msgbuf
        // Instead, use the sbuf members

        int asInt() const;

        void close();
        void open(std::string const &name);     // opens the ofstream
                                                // and uses that stream for
                                                // MsgStream's output

        void msgbuf(std::streambuf *buf);

        using Msgbuf::setLineNr;
        using Msgbuf::showLineNrs;
        using Msgbuf::count;
        using Msgbuf::setMaxCount;
        using Msgbuf::setTag;
        using Msgbuf::msgbuf;

        void setDisplay(bool ifTrue);
        bool display() const;
};

inline void MsgStream::close()
{
    d_ofstream.close();
}

inline bool MsgStream::display() const
{
    return good();
}

inline void MsgStream::setDisplay(bool ifTrue)
{
    if (ifTrue)
        clear();
    else
        setstate(std::ios::badbit);
}

inline void MsgStream::msgbuf(std::streambuf *buf) 
{
    if (good())
        Msgbuf::msgbuf(buf);
}


inline int MsgStream::asInt() const
{
    return reinterpret_cast<int>(this);
}

inline MsgStream::MsgStream(std::ostream *ostr, size_t maxCount, 
                             std::string const &tag, bool throwing)
:
    Msgbuf(ostr, maxCount, tag, throwing),
    std::ostream(this)
{}


} // FBB        
#endif
