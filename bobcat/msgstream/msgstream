#ifndef INCLUDED_BOBCAT_MSGSTREAM_
#define INCLUDED_BOBCAT_MSGSTREAM_

#include <climits>
#include <ostream>
#include <fstream>

#include <bobcat/msgstreambuf>

namespace FBB
{

    // MsgStream cannot be an ostream as ostreams catch exceptions thrown from
    // them and transform them into an error state Cf.:
    // http://www.drdobbs.com/184401357:  
    //      A slightly more serious concern is that the virtual functions in a
    //      class that’s derived from streambuf might throw exceptions;
    //      perhaps, for example, a user-defined class for network I/O might
    //      throw an exception when the underlying connection has been
    //      lost. High-level istream and ostream functions will catch those
    //      exceptions and translate them into an error state within the
    //      stream (that’s one of the reasons that seemingly innocent
    //      functions like istream::get are so complicated), but if you’re
    //      working with stream buffers directly there’s nobody to catch
    //      exceptions for you. If you work with stream buffers, you should
    //      make sure that your code is exception safe.
    // So MsgStream uses its own ostream to handle the outgoing messages and
    // after that tests the stream's state. If not good() and if d_throwing is
    // true then MsgStream throws the exception. The ostream itself is cleared
    // at a not good() anyway.
    //
class MsgStream: private BOBCAT::MsgStreambuf, public std::ostream
{
    friend std::ostream &endm(std::ostream &os);

    typedef MsgStreambuf;

    std::ofstream d_ofstream;

    public:
        MsgStream(std::ostream *ostr, size_t maxCount, 
                     std::string const &tag = "", bool throwing = false);

        // The state-modifying members should not be used as they target
        // MsgStreambuf 
        
        // rdbuf members are still available but will usually result in 
        // unexpected behavior as they return/change MsgStreambuf
        // Instead, use the sbuf members

        int asInt() const;

        void open(std::string const &name);     // opens the ofstream
                                                // and uses that stream for
                                                // MsgStream's output
        using MsgStreambuf::setLineNr;
        using MsgStreambuf::showLineNrs;
        using MsgStreambuf::count;
        using MsgStreambuf::setMaxCount;
        using MsgStreambuf::setTag;
        using MsgStreambuf::msgbuf;

//        using MsgStreambuf::msgContinues;
};

inline int MsgStream::asInt() const
{
    return reinterpret_cast<int>(this);
}

inline void MsgStream::sbuf(std::streambuf *buf)
{
    d_msgStreambuf.rdbuf(buf);
}

inline std::streambuf *MsgStream::sbuf()
{
    return d_msgStreambuf.rdbuf();
}

inline void MsgStream::setLineNr(size_t lineNr, bool ifTrue)
{
    setLineNr(lineNr);
    showLineNrs(ifTrue);
    return *this;
}

inline MsgStream::MsgStream(std::ostream *ostr, size_t maxCount, 
                             std::string const &tag, bool throwing)
:
    MsgStreambuf(ostr, maxCount, tag, throwing),
    std::ostream(this)
{}

std::ostream &endm(std::ostream &os)
{
    os.put('\n').flush();
    if (MsgStream *mp = dynamic_cast<MsgStream *>(&os))
    {
        if (mp->throwing())
            throw 1;
    }
}

} // FBB        
#endif
