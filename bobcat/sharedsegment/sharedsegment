#ifndef INCLUDED_BOBCAT_SHAREDSEGMENT_
#define INCLUDED_BOBCAT_SHAREDSEGMENT_

#include <iosfwd>
#include <cstring>

#include "../sharedblock/sharedblock"

namespace FBB
{

class SharedSegment
{
    friend std::ostream &operator<<(std::ostream &out, 
                                    SharedSegment const &sharedData);

    size_t      d_access;
    size_t      d_segmentSize;

    SharedMutex d_nReadableMutex;
    std::streamsize d_nReadable;    // number of readable characters
                                    // (just beyond offset of last character
                                    // ever written)

    size_t      d_nBlocks;
    SharedBlock d_block[1];         // Mutexes and IDs of shared data blocks
                                    // in fact SharedBlock block[nBlocks]   

    public:
        static SharedSegment *create(int *id, 
                                     size_t nBlocks, size_t segmentSize,
                                     size_t access);

        static size_t size(int id);

                                    // new/delete refer to the shared memory
                                    // itself
        static int newSegment(size_t segmentSize, size_t access);
        static void deleteSegment(int id);  // delete segment having ID id

                                    // attach/detach refer to the mapping 
                                    // on the current process's memory space
        static void *attach(int id);

        template <typename Type>
        static Type *detach(Type *sharedPtr, bool requireOK = true);   
                                            // if sharedPtr != 0 the shared 
                                            // segment is detached. throws
                                            // exception if requireOK == true 
                                            // but detaching fails.
                                            // always returns 0

        SharedSegment(SharedSegment const &other) = delete;
        SharedSegment &operator=(SharedSegment const &rhs) = delete;


        int newData(size_t idx);

        std::streamsize nReadable() const;
        void lock(size_t idx);
        void unlock(size_t idx);

        void lock();                // d_nReadableMutex
        void unlock();

        size_t nBlocks() const;
        size_t segmentSize() const;

        void updateNreadable(std::streamsize offset);
        void clear();               // clear all data, nReadable = 0

        size_t access() const;

        SharedBlock &operator[](size_t idx);

    private:
        static void rawDetach(void *sharedPtr, bool requireOK);  // detaches
                                            // throws exception if 
                                            // requireOK == true 
                                            // but detaching fails

        SharedSegment(size_t access, size_t nBlocks, size_t segmentSize);
        std::ostream &insert(std::ostream &out) const;
};

template <typename Type>
Type *SharedSegment::detach(Type *sharedPtr, bool requireOK)
{
    rawDetach(sharedPtr, requireOK);
    return 0;
}

inline SharedBlock &SharedSegment::operator[](size_t idx)
{
    return d_block[idx];
}

inline void SharedSegment::lock(size_t idx)
{
    d_block[idx].lock();
}

inline void SharedSegment::unlock(size_t idx)
{
    d_block[idx].unlock();
}

inline void SharedSegment::lock()
{
    d_nReadableMutex.lock();
}

inline void SharedSegment::unlock()
{
    d_nReadableMutex.unlock();
}

inline std::streamsize SharedSegment::nReadable() const
{
    return d_nReadable;
}

inline size_t SharedSegment::nBlocks() const
{
    return d_nBlocks;
}

inline size_t SharedSegment::access() const
{
    return d_access;
}

inline size_t SharedSegment::segmentSize() const
{
    return d_segmentSize;
}

inline std::ostream &operator<<(std::ostream &out, 
                                SharedSegment const &sharedData)
{
    return sharedData.insert(out);
}


} // FBB        
#endif



