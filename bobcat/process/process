#ifndef INCLUDED_BOBCAT_PROCESS_
#define INCLUDED_BOBCAT_PROCESS_

#include <string>
#include <memory>
#include <ostream>
#include <istream>

#include <bobcat/fork>
#include <bobcat/string>
#include <bobcat/pipe>
#include <bobcat/selector>
#include <bobcat/ifdstreambuf>
#include <bobcat/ofdstreambuf>

#include <bobcat/iostream>

namespace FBB
{

class Process: private Fork, public IOStream                
{
    std::auto_ptr<Pipe> d_child_inp;    // cin read by the CHILD
    int                 d_fdIn;         // last used redirected pipe Fd
    std::auto_ptr<Pipe> d_child_outp;   // cout written by the CHILD
    int                 d_fdOut;        // last used redirected pipe Fd
    std::auto_ptr<Pipe> d_child_errp;   // cerr written by the CHILD    
    int                 d_fdErr;        // last used redirected pipe Fd

    OFdStreambuf    d_childCinbuf;      // Child extracts,  
    std::ostream    d_childCin;         // Parent inserts to child's cin

    IFdStreambuf    d_childCoutbuf;     // Child inserts,
    std::istream    d_childCout;        // Parent extracts child's cout

    IFdStreambuf    d_childCerrbuf;     // Child inserts
    std::istream    d_childCerr;        // Parent extracts child's cerr

    Selector        d_selector;         // senses activities on Parent's
                                        // outp/errp

    std::string     d_command;

    size_t          d_mode;
    size_t          d_processType;
    size_t          d_waitSeconds;      // seconds to wait for 
                                        // child-termination

    bool            d_active;

    struct RetPid
    {
        int     ret;
        pid_t   pid;

        RetPid();
    };

    RetPid d_child;
    RetPid d_waiter;

    public:
        enum Program
        {
            NO_PATH,
            USE_PATH,
            USE_SHELL,
        };

        enum IOMode
        {
            CIN             = 1 << 0,
            COUT            = 1 << 1,
            CERR            = 1 << 2,
            IGNORE_COUT     = 1 << 3,
            IGNORE_CERR     = 1 << 4,

            MERGE_COUT_CERR = 1 << 5,
        };
        typedef size_t iomode;

        enum TimeOut
        {
            TIMEOUT
        };

                                // prepare the object, don't do anything else
        Process(std::string const &command = "", 
                iomode mode = CIN | COUT | CERR);
        Process(size_t waitSeconds, std::string const &command = "", 
                iomode mode = CIN | COUT | CERR);
        virtual ~Process();     // stop()s any ongoing process

                                // start() calls stop, then starts the
                                // child process followed by the timer-process
        void start(Program program = NO_PATH);
        void start(iomode mode, Program program = NO_PATH);
        void start(size_t waitSeconds, iomode mode,
                                       Program program = NO_PATH);

        void system();          // calls /bin/sh calling cmd; redirs OK
        void system(iomode mode);   // Uses Program USE_SHELL
        void system(size_t waitSeconds, iomode mode);  

        int operator=(std::string const &cmd);  // sets and starts a command


                                // stop inspects the pids. if the child is
                                // running it is terminated, and if the
                                // waiter is running it is terminated
        int stop();
        void close();           // closes input to the child


        std::istream &cerr();   // READ cerr from the child
        size_t available();     // ...

        void setCommand(std::string const &command);    // sets cmd,
                                                        // eats backticks
        Process &operator+=(std::string const &text);   // adds to the command

        std::string const &str() const; // currently set cmd 

        void setPath(Program type);
        void setIOMode(iomode mode);            // NEW changes IOMode
        Process &operator()(iomode mode);

        void setWait(size_t waitSeconds);       // for the next cmd to start
                                                // 0 means: no time monitor

        Process &operator()(size_t waitSeconds, iomode mode);


                                // wait functions are OBSOLETE 
        size_t wait();              
        size_t wait(size_t sec, size_t msec = 0);

        
        template <typename Type>
        Process &operator<<(Type value)
        {
            if (verify())
                dynamic_cast<std::ostream &>(*this) << value;

            return *this;
        }

        Process &operator<<(std::ostream &(*pf)(std::ostream &))
        {
            if (verify())
                dynamic_cast<std::ostream &>(*this) << pf;
            return *this;
        }

        template <typename Type>
        Process &operator>>(Type value)
        {
            if (verify())
                dynamic_cast<IOStream &>(*this) >> value;    // or reinterpret

            return *this;
        }

        bool verify();

    private:
        void forking();
        pid_t discontinue(RetPid &proc);

        void close(std::auto_ptr<Pipe> &pipe, int (Pipe::*fdFun)() const);

        struct ExecContext
        {
            bool ok;                // true: status is ok
            size_t argc;          // must eventually be at least 1
            char const *message;    // only set if !ok
            char const **args;      // 0-terminated array of pointers to the 
                                    // arguments
        };

        static void execContext(String::SplitPair const &splitPair,
                                ExecContext &ec);
        ExecContext analyzeCommand();

        virtual void parentRedirections();
        virtual void parentProcess();
        virtual void childRedirections();
        virtual void childProcess();
        void setPipes(iomode mode);
        Pipe *newPipe() const;
        size_t whichStream();

                                    
        Process(Process const &other);              // NI
        Process &operator=(Process const &other);   // NI
};


inline void Process::start(Program program)
{   
    start(d_waitSeconds, d_mode, program);
}

inline void Process::start(iomode mode, Program program)
{
    start(d_waitSeconds, mode, program);
}

inline Process::~Process()
{
    stop();
}

inline std::istream &Process::cerr()
{
    return d_childCerr;
}

inline void Process::system()
{
    start(USE_SHELL);
}

inline void Process::system(iomode mode)
{
    start(mode, USE_SHELL);
}

inline void Process::parentProcess()
{}

inline void Process::setWait(size_t waitSeconds)
{
    d_waitSeconds = waitSeconds;
}

inline void Process::setIOMode(iomode mode)
{
    d_mode = mode;
}

inline void Process::setPath(Program type)
{
    d_processType = type;
}

inline void Process::close()
{
    ::close(d_child_inp->writeFd());
}

inline std::string const &Process::str() const
{
    return d_command;
}

inline Process &Process::operator()(iomode mode)
{
    return operator()(0, mode);
}

} // FBB        

#endif

// How to preset a program?
//  setCommand  - define program to start

//  setIOMode   - define streams to use
//  setWait     - define max time to run
//  setPath     - use path or shell

// start([NO_PATH])                     - changes path and runs
// start(iomode, [NO_PATH])             - and mode
// start(waitSecs, iomode, [NO_PATH])   - and waitsec

// op= does setCommand and start
