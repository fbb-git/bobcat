#ifndef INCLUDED_BOBCAT_PROCESS_
#define INCLUDED_BOBCAT_PROCESS_

#include <string>
#include <memory>
#include <ostream>
#include <istream>

#include <bobcat/fork>
#include <bobcat/string>
#include <bobcat/pipe>
#include <bobcat/selector>
#include <bobcat/ifdstreambuf>
#include <bobcat/ofdstreambuf>
#include <bobcat/iostream>

namespace FBB
{

//    std::auto_ptr<Pipe> d_child_errp;   // cerr written by the CHILD    
//    IFdStreambuf    d_childCerrbuf;     // Child inserts
//  std::auto_ptr<std::istream>   d_childCerr; // Parent extracts child's cerr


class Process: private Fork, public IOStream
{
    public:
        enum ProcessType
        {
            NO_PATH,
            USE_PATH,
            USE_SHELL
        };
    typedef ProcessType Program;        // OBSOLETE: removed shortly

    private:
        std::auto_ptr<Pipe> d_child_inp;    // cin read by the CHILD
        std::auto_ptr<Pipe> d_child_outp;   // cout written by the CHILD
    
        OFdStreambuf    d_childCinbuf;      // Child extracts,  
        IFdStreambuf    d_childCoutbuf;     // Child inserts,
    
        std::ostream   d_childCin;          // Parent inserts to child's cin
        std::istream   d_childCout;         // Parent extracts child's cout
    
        int d_oldIn;
        int d_oldOut;

        Selector        d_selector;         // senses activities on Parent's
                                            // outp/errp
        size_t          d_mode;
        std::string     d_command;
        ProcessType     d_processType;
        size_t          d_waitSeconds;      // seconds allowed to child-process
        bool            d_active;

    
        struct RetPid
        {
            int     ret;
            pid_t   pid;
    
            RetPid();
        };
        RetPid d_child;
        RetPid d_waiter;

    public:
        enum IOMode
        {
            IGNORE_ALL      = 0,
            CIN             = 1 << 0,
            COUT            = 1 << 1,
            CERR            = 1 << 2,
            IGNORE_COUT     = 1 << 3,
            IGNORE_CERR     = 1 << 4,

            MERGE_COUT_CERR = 1 << 5,
        };
        typedef size_t iomode;

        enum TimeOut
        {
            TIMEOUT
        };
        enum ChildOutput
        {
            NOTHING_AVAILABLE   = 0,
            CHILD_OUTPUT        = 1 << 0,
            CHILD_ERROR         = 1 << 1,
        };
            
        Process(std::string const &command = "");                       // 1
        Process(iomode mode, std::string const &command = "");          // 2
        Process(size_t waitSeconds, iomode mode,                        // 3
                                    std::string const &command = "");
        Process(size_t waitSeconds, iomode mode, ProcessType path,      // 4
                                    std::string const &command = "");

                                            // OBSOLETE                 // obs
        Process(std::string const &command, iomode mode);
        Process(size_t waitSeconds, std::string const &command, iomode mode);

                
        virtual ~Process();                 // stop()s any ongoing process

        void setCommand(std::string const &command);    // sets cmd,
                                                        // eats backticks
        Process &operator+=(std::string const &text);   // adds to the command
        
        void start();
        void start(ProcessType type);
        void start(iomode mode, ProcessType type);
        void start(size_t waitSeconds, iomode mode, ProcessType type);

        void system();              // calls /bin/sh -c cmd; shell redirs OK
        void system(iomode mode);   
        void system(size_t waitSeconds, iomode mode);  


        int operator=(std::string const &cmd);  // sets and starts a command


        std::string const &str() const; // current command

        int stop();                     // terminate a running childprocess

        template <typename Type>
        Process &operator<<(Type value);

        Process &operator<<(std::ostream &(*pf)(std::ostream &));

        template <typename Type>
        Process &operator>>(Type value);

        bool verify();

        void setIOMode(iomode mode);            // change IOMode

        void setPath(ProcessType type);         // OBS: use setProcessType
        void setProcessType(ProcessType type);

        void setWait(size_t waitSeconds);       // for the next cmd to start
                                                // 0 means: no time monitor

        Process &operator()(iomode mode);       // set things using function 
        Process &operator()(size_t waitSeconds, iomode mode);   //  objects 
        Process &operator()(size_t waitSeconds, iomode mode, ProcessType type);

        void close();                           // closes input to the child

        std::istream &cerr();                   // READ cerr from the child

        size_t available();                     // returns ChildOutput bit_or
                                                // (cf. manpage)
        int waitForChild();                     // cf. manpage

                                
        size_t wait();                      // OBSOLETE     
        size_t wait(size_t sec, size_t msec = 0);



    private:
        size_t whichStream();
        Pipe *newPipe() const;
        pid_t discontinue(RetPid &proc);
        virtual void childProcess();
        virtual void childRedirections();
        virtual void parentProcess();
        virtual void parentRedirections();
        void forking();
        void setPipes(iomode mode);

        struct ExecContext
        {
            bool ok;                // true: status is ok
            size_t argc;            // must eventually be at least 1
            char const *message;    // only set if !ok
            char const **args;      // 0-terminated array of pointers to the 
                                    // arguments
        };
        static void execContext(String::SplitPair const &splitPair,
                                ExecContext &ec);
        ExecContext analyzeCommand();
                                    
        Process(Process const &other);              // NI
        Process &operator=(Process const &other);   // NI
};

inline Process::~Process()
{
    stop();
}

inline void Process::start()
{   
    start(d_waitSeconds, d_mode, d_processType);
}

inline void Process::start(ProcessType type)
{   
    start(d_waitSeconds, d_mode, type);
}

inline void Process::start(iomode mode, ProcessType type)
{
    start(d_waitSeconds, mode, type);
}

inline void Process::parentProcess()
{}

template <typename Type>
Process &Process::operator<<(Type value)
{
    if (verify())
        dynamic_cast<std::ostream &>(*this) << value;

    return *this;
}

template <typename Type>
Process &Process::operator>>(Type value)
{
    if (verify())
        dynamic_cast<std::istream &>(*this) >> value;    // or reinterpret

    return *this;
}

inline void Process::setIOMode(iomode mode)
{
    d_mode = mode;
 }

inline std::string const &Process::str() const
{
    return d_command;
}

inline void Process::system()
{
    start(USE_SHELL);
}

inline void Process::system(iomode mode)
{
    start(mode, USE_SHELL);
}

inline void Process::system(size_t waitSeconds, iomode mode)
{
    start(waitSeconds, mode, USE_SHELL);
}

inline Process &Process::operator+=(std::string const &command)
{
    d_command += command;
    return *this;
}

inline void Process::setCommand(std::string const &command)
{
    d_command = command;
}

inline void Process::setProcessType(ProcessType type)
{
    d_processType = type;
}

inline void Process::setWait(size_t waitSeconds)
{
    d_waitSeconds = waitSeconds;
}

inline Process &Process::operator()(iomode mode)
{
    return operator()(d_waitSeconds, mode, d_processType);
}

inline Process &Process::operator()(size_t waitSeconds, iomode mode)
{
    return operator()(waitSeconds, mode, d_processType);
}

inline int Process::waitForChild()
{
    return Fork::waitForChild();
}

//inline std::istream &Process::cerr()
//{
//    return *d_childCerr;
//}

} // FBB        

#endif


