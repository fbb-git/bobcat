#ifndef INCLUDED_BOBCAT_TABLESUPPORT_
#define INCLUDED_BOBCAT_TABLESUPPORT_

#include <ostream>
#include <vector>
#include <unordered_map>
#include <numeric>

#include <bobcat/align>

namespace FBB
{

class TableSupport
{
    protected:    
        struct BeginEnd     
        {
            size_t begin;       // first column to use
            size_t end;         // first column not to use anymore
            int type;           // handlingtype, including margins
        };                      // before begin and at end.
            // type values: Type (below) or combis of LRMargin

    public:
        enum ColumnType
        {
            SKIP,
            USE,
            LEFT_FULL = 2,  
            LEFT_MID  = 4,
            RIGHT_FULL= 8,
            RIGHT_MID = 16
        };

                // define the columns to provide with a (partial) hline
        struct HLine
        {
            size_t d_row;
            size_t d_begin;
            size_t d_end;
            size_t d_type;  
        
            HLine(size_t row, size_t begin, size_t end);
            HLine(ColumnType margins, size_t row, size_t begin, size_t end);
        };

//        class const_iterator:
//            public std::iterator<std::input_iterator_tag, Element>
//        {
//            TableSupport const &d_support;
//            size_t  d_col;      // the column this iterator refers to
//            bool    d_sep;
//
////                                // iterators to Element structs of columns
////                                // and separators.
////            std::vector<BeginEnd>::const_iterator d_begin;
////            std::vector<BeginEnd>::const_iterator d_end;
////
////            Element d_element;  // Type and width of a column/separator
//            
//            public:
//                const_iterator(TableSupport const &support);
//                const_iterator(TableSupport const &support, 
//                               std::vector<BeginEnd> const &field);
//
//                const_iterator &operator++();
//
//                int operator-(const_iterator const &rhs) const;
//
//                bool operator==(const_iterator const &other) const;
//                bool operator!=(const_iterator const &other) const;
//                Element const &operator*() const;
//                Element const *operator->() const;
//                size_t size() const
//                {
//                    return d_begin->end - d_begin->begin;
//                }
//            private:
//                void setElement();
//        };

    private:
        std::ostream *d_streamPtr;
        size_t d_nRows;                     // # of rows (defined after def())
        size_t d_nColumns;                  // # of cols
        std::vector<Align> const *d_align;  // pointer to alignment info,
                                            // passed to this by setParam,
                                            // (used by Table/TableBuf)
        size_t d_tableWidth;                // total table width
        std::vector<std::string> d_sep;     // a vector of separators. 0:
                                            // before the leftmost col.

                                            // Element types per row per
                                            // column, wrt hlines
        std::unordered_map<size_t, std::vector<size_t>> d_elements;

    public:
        TableSupport();

        virtual ~TableSupport();

        void setParam(std::ostream &ostr, size_t rows, size_t nColumns,
                        std::vector<Align> const &align);

        size_t width() const;               // total width of the table
                                            
            // called for each row (0: before 1st data row)
        virtual void hline(size_t row) const;
        virtual void hline() const;         // called after the last data row

            // same for columns
        virtual void vline(size_t col) const;
        virtual void vline() const;


//        SizeBeginEndMap const &hlineMap() const;
//        const_iterator begin(size_t row) const;
//        const_iterator end() const;

        size_t colWidth(size_t col) const;  // width of a column and:
        size_t sepWidth(size_t col) const;  // of a separator (0: leftmost)
        size_t nColumns() const;            // number of columns
        size_t nRows() const;               // number of rows

        std::ostream &out() const;          // stream to insert into the tab.

                                            // col. alignmnts (not separators)
        std::vector<Align> const &align() const;
        std::vector<std::string> const &sep() const;    // separators

    private:
            // return indices in d_elements of left separator element, etc.
        static size_t leftSeparator(size_t column); 
        static size_t element(size_t column); 
        static size_t rightSeparator(size_t column); 

        static void leftType(size_t *target, size_t type);
        static void rightType(size_t *target, size_t type);

        static void add(std::string const &src, size_t &dest);

//        friend class const_iterator;
        friend TableSupport &operator<<(TableSupport &support, size_t);
        friend TableSupport &operator<<(TableSupport &support, 
                                                    std::string const &sep);
        friend TableSupport &operator<<(TableSupport &support, 
                                                    HLine const &hline);
};


inline size_t TableSupport::colWidth(size_t col) const
{
    return col < d_align->size() ? (*d_align)[col].col() : 0;
}

inline size_t TableSupport::sepWidth(size_t col) const
{
    return col < d_sep.size() ? d_sep[col].length() : 0;
}

//inline TableSupport::const_iterator TableSupport::end() const
//{
//    return const_iterator(*this);
//}

inline size_t TableSupport::width() const
{
    return d_tableWidth;
}

inline std::ostream &TableSupport::out() const
{
    return *d_streamPtr;
}

inline void TableSupport::hline(size_t row) const
{}

inline void TableSupport::hline() const
{
    hline(d_nRows);
}

//inline TableSupport::SizeBeginEndMap const &TableSupport::hlineMap() const
//{
//    return d_hline;
//}

inline std::vector<std::string> const &TableSupport::sep() const
{
    return d_sep;
}

inline size_t TableSupport::nColumns() const
{
    return d_nColumns;
}

inline size_t TableSupport::nRows() const
{
    return d_nRows;
}

inline std::vector<Align> const &TableSupport::align() const
{
    return *d_align;
}

//inline bool TableSupport::const_iterator::operator==(
//        TableSupport::const_iterator const &other) const
//{
//    return d_sep == other.d_sep && d_col == other.d_col;
//}
//
//inline bool TableSupport::const_iterator::operator!=(
//    TableSupport::const_iterator const &other) const
//{
//    return not (*this == other);
//}
//
//inline TableSupport::Element const 
//    *TableSupport::const_iterator::operator->() const
//{
//    return &d_element;
//}
//
//inline TableSupport::Element const 
//    &TableSupport::const_iterator::operator*() const
//{
//    return *operator->();
//}

TableSupport &operator<<(TableSupport &support, size_t);
TableSupport &operator<<(TableSupport &support, std::string const &sep);
TableSupport &operator<<(TableSupport &support, 
                                        TableSupport::HLine const &hline);

// inline TableSupport::LRMargins operator|(TableSupport::LRMargins lhs,
//                                          TableSupport::LRMargins rhs)
// {
//     return static_cast<TableSupport::LRMargins>(
//                 static_cast<int>(lhs) | static_cast<int>(rhs));
// }

} // FBB


#endif
