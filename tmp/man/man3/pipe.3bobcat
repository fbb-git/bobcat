.TH "FBB::Pipe" "3bobcat" "2005-2006" "libbobcat1-dev_1\&.10\&.0-x\&.tar\&.gz" "Error handler"

.PP 
.SH "NAME"
FBB::Pipe \- Defines a system level pipe
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/pipe>\fP
.br 
Linking option: \fI-lbobcat\fP 
.PP 
.SH "DESCRIPTION"
\fBFBB::Pipe\fP objects may be used to construct a \fIpipe\fP\&. \fBFBB::Pipe\fP
objects offer a simple interface to the reading and writing ends of
pipes\&. \fBFBB::Pipe\fP objects are object-wrappers around the \fBpipe\fP(2) system
call\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
-
.PP 
.SH "CONSTRUCTORS"
.IP o 
\fBPipe()\fP:
.br 
The default \fBPipe()\fP constructor constructs a basic pipe, calling
\fBpipe\fP(2)\&. If the construction fails, an \fBFBB::Errno\fP object is thrown,
whose \fIwhich()\fP member shows the system\&'s \fIerrno\fP value set by the failing
\fBpipe\fP(2) function\&.
.IP o 
\fBPipe(int const *fd)\fP:
.br 
This constructor expects two file descriptors, which already define a
pipe\&.
.IP o 
\fBPipe(Pipe const &other) throw()\fP:
.br 
The standard copy constructor is available\&.
Note that when the pipe goes out of scope, no \fBclose\fP(2) operation is
performed on the pipe\&'s ends\&. If the pipe should be closed by the desctructor,
derive a class from \fBPipe\fP(3bobcat), whose destructor performs the required
closing-operation\&.
.PP 
.SH "MEMBER FUNCTIONS"
.IP o 
\fBint readFd() const\fP:
.br 
Returns the pipe\&'s file descriptor that is used for reading
.IP o 
\fBvoid readFrom(int filedescriptor)\fP:
.br 
Sets up redirection from the internal \fIread\fP filedescriptor to the
given filedescriptor: information can be read from the \fBFBB::Pipe\fP object by
reading from the provided filedescriptor\&.
.IP o 
\fBvoid readFrom(int const *filedescriptors, unsigned n)\fP:
.br 
Sets up redirection from the internal \fIread\fP filedescriptor to the
given filedescriptors: information can be read from the \fBFBB::Pipe\fP object by
reading from each of the \fBn\fP provided filedescriptors (experimental)\&.
.IP o 
\fBint readOnly()\fP:
.br 
Closes the writing end of the pipe, returns the reading end\&'s file
descriptor\&. 
.IP o 
\fBint writeFd() const\fP:
.br 
Returns the pipe\&'s file descriptor that is used for writing
.IP o 
\fBvoid writtenBy(int filedescriptor)\fP:
.br 
Sets up redirection from the internal \fIwrite\fP filedescriptor to the
given filedescriptor: information can be written to the \fBFBB::Pipe\fP object by
writing to the provided filedescriptor\&.
.IP o 
\fBvoid writtenBy(int const *filedescriptors, unsigned n)\fP:
.br 
Sets up redirection from the internal \fIwrite\fP filedescriptor to the
given filedescriptors: information can be written to the \fBFBB::Pipe\fP object
by writing to each of the \fBn\fP provided filedescriptors\&.
.IP o 
\fBint writeOnly()\fP:
.br 
Closes the writing end of the pipe, returns the writing end\&'s file
descriptor\&. 

.PP 
.SH "PROTECTED ENUMERATION"
The \fBRW\fP protected enumeration has the following elements:
.IP o 
\fBREAD\fP:
.br 
The index in \fBd_fd[]\fP (see below) of the element holding the pipe\&'s
reading file descriptor;
.IP o 
\fBWRITE\fP:
.br 
The index in \fBd_fd[]\fP (see below) of the element holding the pipe\&'s
writing file descriptor

.PP 
.SH "PROTECTED DATA"
.IP o 
\fBint d_fd[2]\fP:
.br 
The array holding the pipe\&'s file descriptors\&. The \fBREAD\fP element
contains the pipe\&'s reading file descriptor, the \fBWRITE\fP element
contains the pipe\&'s writing file descriptor,

.PP 
.SH "EXAMPLE"
.nf 

    #include <bobcat/pipe>
    #include <sys/types\&.h>
    #include <sys/wait\&.h>
    #include <unistd\&.h>
    #include <iostream>
    #include <string>
    
    using namespace std;
    using namespace FBB;
    
    int main()
    {
        Pipe p;                         // construct a pipe
    
        cout << "Read file descriptor: " << p\&.getReadFd() << endl;
        cout << "Write file descriptor: " << p\&.getWriteFd() << endl;
    
        int pid = fork();
    
        if (pid == -1)
            return 1;
    
        if (!pid)                       //child
        {
            p\&.readFrom(STDIN_FILENO);   // read what goes into the pipe
    
            string s;

            getline(cin, s);
            cout << "CHILD: Got `" << s << "\&'" << endl;    
    
            getline(cin, s);
            cout << "CHILD: Got `" << s << "\&'" << endl;    
    
            return 0;
        }
    
        p\&.writtenBy(STDOUT_FILENO);      // write to the pipe via cout
    
        cout << "first line" << endl;
        cout << "second line" << endl;
    
        waitpid(pid, 0, 0);
    
        return 0;
    }
        
.fi 

.PP 
.SH "FILES"
\fIbobcat/pipe\fP - defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBpipe\fP(2)
.PP 
.SH "BUGS"
Note that when the pipe goes out of scope, no \fBclose\fP(2) operation is
performed on the pipe\&'s ends\&. If the pipe should be closed by the desctructor,
derive a class from \fBPipe\fP(3bobcat), whose destructor performs the required
closing-operation\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_1\&.10\&.0-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_1\&.10\&.0-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_1\&.10\&.0-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_1\&.10\&.0-x_i386\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1-dev_1\&.10\&.0-x_i386\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\&'s Own Base Classes And Templates\&'\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
Academic Free Licence\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 
