.TH "FBB::MailHeaders" "3bobcat" "2005-2006" "libbobcat1-dev_1\&.10\&.0-x\&.tar\&.gz" "SMTP Mail Headers"

.PP 
.SH "NAME"
FBB::MailHeaders \- Handles SMTP Mail Headers
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/mailheaders>\fP
.br 
Linking option: \fI-lbobcat\fP 
.PP 
.SH "DESCRIPTION"

.PP 
\fBFBB::MailHeaders\fP objects extract header lines from e-mail\&. Reading
stops at (and including) the first blank line, which becomes the last element
of the \fBFBB::MailHeaders\fP object, interpreted as a \fBvector\fP\&. The actual
e-mail content is therefore left unread on the file containing the e-mail\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"
\fBstd::vector<std::string>\fP
.PP 
.SH "ENUMERATIONS"
The following enumerations are defined in the class \fBFBB::MailHeaders\fP:
.PP 
\fBenum Mode\fP
.br 
This enumeration holds two values:
.IP o 
\fBREAD\fP:
.br 
When this value is specified at construction time, e-mail is
immediately read by the constructor\&.
.IP o 
\fBDONT_READ\fP:
.br 
When this value is specified at construction time, e-mail is read
using the \fBread()\fP member (see below)\&.

.PP 
\fBenum Match\fP
.br 
This enumeration holds four values:
.IP o 
\fBFAIL\fP:
.br 
Not to be used by public members\&.
.IP o 
\fBFULL\fP:
.br 
Used by the \fBsetHeaderIterator\fP (see below) to indicate that the headers
must exactly match a specified header name\&.
.IP o 
\fBINITIAL\fP:
.br 
Used by the \fBsetHeaderIterator\fP (see below) to indicate that the initial
part of the headers must match the specified header text\&.
.IP o 
\fBPARTIAL\fP:
.br 
Used by the \fBsetHeaderIterator\fP (see below) to indicate that the 
headers must contain the specified header text\&.

.PP 
.SH "CONSTRUCTOR"
.IP o 
\fBMailHeaders(std::istream &in, Mode mode = READ)\fP:
.br 
This constructor defines the file containing the e-mail to be
processed\&. The second parameter is by default \fBMailHeaders::READ\fP, causing
the object to start reading the e-mail immediately\&. If set to
\fBMailHeaders::DONT_READ\fP, the e-mail is not read\&. In that case the member
\fIread()\fP can be called to process the e-mail later\&.
The standard copy constructor is available\&.
.PP 
.SH "MEMBER FUNCTIONS"
All members of \fBstd::vector<std::string>\fP are available, as \fBFBB::MailHeaders\fP
inherts from this class\&.
.PP 
.IP o 
\fBvoid read()\fP:
.br 
Reads the mail-headers from the file passed to the \fBFBB::MailHeaders\fP object\&'s
constructor\&. An \fBFBB::Errno\fP object is thrown if the mailheaders were
already read or if the file is incomplete (i\&.e\&., the (obligatory) blank line
wasn\&'t found)\&.
.IP o 
\fBvoid setHeaderIterator(char const *header, Match match = FULL)\fP:
.br 
Sets the header-iterators to the specified \fIheader\fP\&. The parameter
\fImatch\fP defines the match-type used for recognizing the header\&. By default
it is \fBFBB::MailHeaders::FULL\fP, meaning that the text provided in \fIheader\fP must
match exactly an e-mail header (e\&.g\&., \fIFrom\fP won\&'t match a \fIFrom:\fP
header)\&. Other matching strategies are \fBFBB::MailHeaders::INITIAL\fP, meaning that
\fIheader\fP must match the \fIinitial\fP text of an e-mail header (e\&.g\&., \fIFrom\fP
matches a \fIFrom:\fP header); and \fBFBB::MailHeaders::PARTIAL\fP, meaning that \fIheader\fP
must match the \fIinitial\fP text of an e-mail header (e\&.g\&., \fIom\fP matches
matches a \fIFrom:\fP header (but also a \fIFrom\fP header))\&. An \fBFBB::Errno\fP
exception is thrown if \fBsetHeaderIterator()\fP is called when no mail headers
are available\&.
.IP o 
\fBconst_iterator beginh() const\fP:
.br 
Returns the begin-iterator (a \fBFBB::MailHeaders:const_iterator\fP object)
corresponding to the header and matching type defined by
\fBsetHeaderIterator()\fP\&. \fBendh()\fP is returned if no such header is
available\&. Note that the member function ends in \fIh\fP, in order to
distinguish it from the \fBvector<string>::begin()\fP member\&. The
\fBFBB::MailHeaders:const_iterator\fP is an iterator to a \fIvector<unsigned>\fP
object, containing the indices in the \fBFBB::MailHeaders\fP vector where the
particular header information is found\&. If the header line consists of only
one line, then the iterator points to a vector holding just one index\&. Headers
extending over multiple lines have the indices of these lines stored in the
returned vector\&.
.IP o 
\fBconst_iterator endh() const\fP:
.br 
Returns the end-iterator (a \fBFBB::MailHeaders:const_iterator\fP object)
corresponding to the header and matching type defined by
\fBsetHeaderIterator()\fP\&. Note that the member function ends in \fIh\fP, in order
to distinguish it from the \fBvector<string>::end()\fP member\&.
.IP o 
\fBconst_reverse_iterator rbeginh() const\fP:
.br 
Returns the reversed begin-iterator (a
\fBFBB::MailHeaders:const_reverse_iterator\fP object) corresponding to the
header and matching type defined by \fBsetHeaderIterator()\fP\&. \fBrendh()\fP is
returned if no such header is available\&. Note that the member function ends in
\fIh\fP, in order to distinguish it from the \fBvector<string>::rbegin()\fP
member\&.
.IP o 
\fBconst_iterator rendh() const\fP:
.br 
Returns the end-iterator (a \fBFBB::MailHeaders:const_reverse_iterator\fP
object) corresponding to the header and matching type defined by
\fBsetHeaderIterator()\fP\&. Note that the member function ends in \fIh\fP, in order
to distinguish it from the \fBvector<string>::rend()\fP member\&.

.PP 
.SH "EXAMPLE"
The following example shows the normal use of these manipulators:
.nf 

                // create a MailHeader object
    MailHeaders mh(cin, MailHeaders::DONT_READ);

    try
    {           // read the headers
        mh\&.read();
    }
    catch (Errno &err)
    {
        cout << err\&.what() << endl;
    }

    cout << "There are " << mh\&.size() << " header lines\en";

                // look for the Received: headers    
    mh\&.setHeaderIterator("Received:");

                // iterators returning vectors of line numbers
    for (MailHeaders::const_iterator it = mh\&.beginh(); it != mh\&.endh(); it++)
    {
        for 
        (       // iterators returning line numbers
            vector<unsigned>::const_iterator nr = it->begin(); 
                nr != it->end();
                    nr++
        )       
            cout << mh[*nr] << endl;    // print lines of MailHeader object

                // separate each full Received header by +\&'s
        cout << "+++++++++++++++++++++++++++++++" << endl;
    }
    
.fi 

.PP 
.SH "FILES"
\fIbobcat/mailheaders\fP - defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7)
.PP 
.SH "BUGS"
None Reported\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_1\&.10\&.0-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_1\&.10\&.0-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_1\&.10\&.0-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_1\&.10\&.0-x_i386\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1-dev_1\&.10\&.0-x_i386\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\&'s Own Base Classes And Templates\&'\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
Academic Free Licence\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 
