.TH "FBB::Wrap2" "3bobcat" "2005-2006" "libbobcat1-dev_1\&.10\&.0-x\&.tar\&.gz" "Binary Wrapper"

.PP 
.SH "NAME"
FBB::Wrap2 \- STL binary argument wrapper template class
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/wrap2>\fP
.br 

.PP 
.SH "DESCRIPTION"
The \fBFBB::Wrap2\fP class is a configurable binary argument wrapper
template class\&. Its primary use is in combination with the generic algorithms
of the standard template libray\&.
.PP 
The callled function itself may be specified as one of the constructor\&'s
arguments\&. It must be a (static member) function\&. Using a (static member)
function has various advantages, especially with the \fBWrap?c\fP classes to
which a \fIlocal context\fP can be passed:
.IP o 
There is no introduced uncertainty about the \fBconst\fP-ness of the
callled function, as static member functions do not support 
a \fBconst\fP modifier;
.IP o 
The passed function can also be a free (global) function to which a
local context is passed;
.IP o 
The passed function can be a static member function of the class
using the generic algorithm to which the \fBFBB::Wrap2\fP object is passed\&. By
passing the calling object in the function\&'s local context, the function may
directly access the calling object\&'s members\&.
.IP o 
The passed function can be a static member function of the class
whose objects are passed to the function via the generic template function s
iterator parameters\&. In that case the function may directly access the passed
object\&'s members\&.
.IP o 
Since no object is involved in calling the static function, no
ambiguity can arise as to whether an object reference or an object pointer
should be used in calling the function: static (member) functions may be
called without using objects\&.

.PP 
The \fBFBB::Wrap2\fP template class has the following template parameters:
.IP o 
\fIType1\fP: the type of the first object passed to \fBFBB::Wrap2\fP\&'s
\fBoperator()()\fP function\&. Specify a \fBplain\fP type, do not specify a pointer
or reference type: if pointers or references are used, it will become obvious
later on, as the template will be able to handle (const) references and
pointers\&. Values of primitive types may be handled as const-references\&.
.IP o 
\fIType2\fP: the type of the second object passed to \fBFBB::Wrap2\fP\&'s
\fBoperator()()\fP function\&. Specify a \fBplain\fP type, do not specify a pointer
or reference type: if pointers or references are used, it will become obvious
later on, as the template will be able to handle (const) references and
pointers\&. Values of primitive types may be handled as const-references\&.
.IP o 
\fIReturnType\fP: the \fBReturnType\fP is by default defined as \fIvoid\fP\&. By
specifying another type, the \fBFBB::Wrap2\fP object\&'s \fBoperator()()\fP function
will pass the called function\&'s return value as a value of the specified
type\&. E\&.g, by specifying a \fIbool\fP \fBReturnType\fP, the \fBFBB::Wrap2\fP object
may be used as a \fIBinary Predicate\fP

.PP 
.SH "NAMESPACE"
FBB
.PP 
.SH "INHERITS FROM"
-
.PP 
.SH "CONSTRUCTORS"
.IP o 
\fBWrap1<Type1, Typ2 [, Returntype = void]>(ReturnType (*fun)(Type1 &,
Type2 &))\fP:
.br 
.br 
This constructor expects one argument: the address of a function that
is called by its \fBoperator()()\fP member\&.  The function receives
\fBFBB::Wrap2\fP\fB::operator()()\fP arguments as its arguments\&. The template
parameters \fIType1\fP and \fIType2\fP are the data types to which iterators
eventually point\&.
.IP o 
\fBWrap1<Type1, Typ2 [, Returntype = void]>(ReturnType 
(*fun)(Type1 const &, Type2 const &))\fP:
.br 
.br 
This constructor is identical to the first constructor, except for the
actual type parameters that are passed to the function, which are
now \fIType const &\fPs\&.
.IP o 
\fBWrap1<Type1, Typ2 [, Returntype = void]>(ReturnType 
(*fun)(Type1 *, Type2 *))\fP:
.br 
.br 
This constructor is identical to the first constructor, except for the
actual type parameters that are passed to the function, which are
now \fIType *\fPs\&.
.IP o 
\fBWrap1<Type1, Typ2 [, Returntype = void]>(ReturnType 
(*fun)(Type1 const *, Type2 const *))\fP:
.br 
.br 
This constructor is identical to the first constructor, except for the
actual type parameters that are passed to the function, which are
now \fIType const *\fPs\&.

.PP 
.SH "OVERLOADED OPERATORS"

.PP 
In normal situations the following member functions will call the function
that\&'s passed to \fBFBB::Wrap2\fP\&'s constructor\&. See the example below\&.
.PP 
.IP o 
\fBReturnType operator()(Type1 &param1, Type2 &param2) const\fP:
.br 
This function is called by the generic algorithms, receiving the
dereferenced iterators that are managed by the generic algorithm as its
arguments (so, the iterators point to modifiable \fIType1\fP and \fIType2\fP
objects)\&. This operator is used with the first constructor\&.
.IP o 
\fBReturnType operator()(Type1 const &param1, Type2 const &param2) const\fP:
.br 
This function is called by the generic algorithms, receiving the
dereferenced iterators that are managed by the generic algorithm as its
arguments (so, the iterators point to immutable \fIType1\fP and \fIType2\fP
objects)\&. This operator is used with the first constructor\&.
.IP o 
\fBReturnType operator()(Type1 *param1, Type2 *param2) const\fP:
.br 
This function is called by the generic algorithms, receiving the
dereferenced iterators that are managed by the generic algorithm as its
arguments (so, the iterators points to pointers to modifiable \fIType1\fP and
\fIType2\fP objects)\&. This operator is used with the third constructor\&.
.IP o 
\fBReturnType operator()(Type1 const *param1, Type2 const *param2) const\fP:
.br 
This function is called by the generic algorithms, receiving the
dereferenced iterators that are managed by the generic algorithm as its
arguments (so, the iterators points to pointers to immutable \fIType1\fP and
\fIType2\fP objects)\&. This operator is used with the fourth constructor\&.

.PP 
.SH "TYPEDEFS"

.PP 
The class defines three types, which are used by generic algorithms:
.IP o 
\fBfirst_argument_type\fP:
.br 
, a synonym for \fBType1\fP;
.IP o 
\fBsecond_argument_type\fP:
.br 
, a synonym for \fBType2\fP;
.IP o 
\fBresult_type\fP:
.br 
, a synonym for \fBReturnType\fP\&.

.PP 
.SH "EXAMPLES"
.nf 

    #include <algorithm>
    #include <iostream>
    #include <vector>
    #include <string>   
    #include <functional>
    #include <bobcat/wrap2>
    
    using namespace std;
    using namespace FBB;
    
    bool cmp(string &actual, string &target)
    {
        cout << "Saw " << actual << endl;
        bool ret = actual == target;
        actual += "\&.";
        return ret;
    }
    
    class X
    {
        public:
            static bool cmp(string const &actual, string const &target)
            {
                cout << "Saw " << actual << endl;
                return actual == target;
            }
    };
    
    int main(int argc, char **argv)
    {
        vector<string> vs(argv, argv + argc);
    
        find_if(vs\&.begin(), vs\&.end(), 
            bind2nd(Wrap2<string, string, bool>(&cmp), string("hello")));
    
        cout << endl;
    
        find_if(vs\&.begin(), vs\&.end(), 
            bind2nd(Wrap2<string, string, bool>(&X::cmp), string("hello")));
    }
        
.fi 

.PP 
.SH "FILES"
\fIbobcat/wrap2\fP - defines the class interface
.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBwrap1\fP(3bobcat), \fBwrap1c\fP(3bobcat), 
\fBwrap2c\fP(3bobcat)
.PP 
.SH "BUGS"
None Reported\&.
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_1\&.10\&.0-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_1\&.10\&.0-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_1\&.10\&.0-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_1\&.10\&.0-x_i386\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1-dev_1\&.10\&.0-x_i386\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\&'s Own Base Classes And Templates\&'\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
Academic Free Licence\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 
