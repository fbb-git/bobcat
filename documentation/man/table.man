.TH "FBB::Table" "3bobcat" "2005-2007" "libbobcat1-dev_1\&.14\&.1-x\&.tar\&.gz" "Table-formatter"

.PP 
.SH "NAME"
FBB::Table \- Generates row- or column-wise filled tables
.PP 
.SH "SYNOPSIS"
\fB#include <bobcat/table>\fP
.br 
Linking option: \fI-lbobcat\fP 
.PP 
.SH "DESCRIPTION"

.PP 
\fBFBB::Table\fP objects may be used to create tables\&. The tables are filled
either column-wise or row-wise\&. Many of the table\&'s characteristics may be
fine-tuned by a separate \fBFBB::TableSupport\fP object, described in a separate
man-page (\fBTableSupport\fP(3bobcat))\&. When no \fBFBB::TableSupport\fP object is
used, a plain row-wise or column-wise table will be constructed which can be
inserted into a \fBstd::ostream\fP\&.
.PP 
.SH "NAMESPACE"
\fBFBB\fP
.br 
All constructors, members, operators and manipulators, mentioned in this
man-page, are defined in the namespace \fBFBB\fP\&.
.PP 
.SH "INHERITS FROM"

.PP 
\fBstd::ostringstream\fP - \fBTable\fP inherits from \fBstd::ostringstream\fP,
allowing insertions into a \fBTable\fP object\&. Each separate insertion adds
another element to the \fBTable\fP object\&.
.PP 
.SH "ENUMERATIONS"
The following enumerations are defined in the class \fBFBB::TableSpec\fP,
allowing the programmer to specifiy values like \fBFBB::TableSpec::Vertical\fP
rather than \fBFBB::Table<std::istream_const_iterator>::Vertical\fP\&.
.PP 
\fBenum FillDirection\fP
.br 
This enumeration holds two values:
.IP o 
\fBROWWISE\fP:
.br 
When this value is specified at construction time, elements are added
row-wise to the table\&. I\&.e\&., the second element inserted into the \fBTable\fP
will be found in the second column of the first row\&.
.IP o 
\fBCOLUMNWISE\fP:
.br 
When this value is specified at construction time, elements are added
column-wise to the table\&. I\&.e\&., the second element will be found in the second
row of the first column\&.

.PP 
\fBenum WidthType\fP
.br 
This enumeration holds two values:
.IP o 
\fBCOLUMNWIDTH\fP:
.br 
This value may be specified when the columns should be allowed
variable widths\&. In this case each column will be as wide as its widest
element\&. This is the default \fBWidthType\fP used by \fBTable\fP objects\&. 
.IP o 
\fBEQUALWIDTH\fP:
.br 
This value may be specified when all the table\&'s columns should have
equal width (i\&.e\&., equal to the width of the widest table element), 

.PP 
.SH "CONSTRUCTORS"
.IP o 
\fBTable(size_t nColumns, Table::FillDirection direction,
Table::WidthType widthType = Table::COLUMNWIDTH)\fP:
.br 
This constructor expects the table\&'s number of columns\&.  The number of
rows are implied by the combination of this parameter and the number of
elements that will be inserted into the \fBTable\fP object\&.  The \fBdirection\fP
parameter specifies the way new elements will be added to the \fBTable\fP
object: row-wise or column-wise\&. Finally, the \fIwidthType\fP parameter is used
to specify the way the width of the table\&'s columns is determined: each column
may either have its own width or all columns will have equal widths\&.
.IP o 
\fBTable(TableSupport &tableSupport, Table::FillDirection direction,
Table::WidthType widthType = Table::COLUMNWIDTH)\fP:
.br 
This constructor operates identically to the previous constructor, but
expects an additional reference to a \fBTableSupport\fP object\&. A
\fBTableSupport\fP object offers additional formatting features used by the
table to define elements like horizontal lines between rows, additional
separators between elements etc\&. Note that the \fBTableSupport\fP object is
passed as a non-const reference as the \fBTable\fP object must be able to
manipulate its data\&.
The copy constructor is not available\&.
.PP 
.SH "OVERLOADED OPERATORS"

.PP 
.IP o 
\fBstd::ostream &operator<<(std::ostream &str, Table const &table)\fP:
.br 
This operator inserts a \fBTable\fP into a \fIstd::ostream\fP object\&.
.IP o 
\fBTable &operator<<(Table &obj, Align const &align)\fP:
.br 
This operator is used to change the default alignment of either a
column or an element\&. It is a wrapper around the member \fIsetAlign()\fP (see
below for its description)\&. By default, all elements are right-aligned\&.
.IP o 
\fBTable &operator<<(Table &obj, Type const &x)\fP:
.br 
This overloaded operator is defined as a template: \fBType\fP is a
template type parameter instantiated to a type for which
\fBstd::ostringstream\fP insertions are possible\&.  It inserts the value/object
\fIx\fP into the \fBTable\fP\&'s \fBstd::ostringstream\fP base class object as the
next element of the table\&.
The overloaded assignment operator is not available\&.
.PP 
.SH "MEMBER FUNCTIONS"
.IP o 
\fBTable &append(std::string const &text
char const *sep = " \et", bool addEmpty = false)\fP:
.br 
This member adds all fields in \fItext\fP separated by one of the
characters in \fIsep\fP as additional elements to the \fBTable\fP object\&. Empty
fields are ignored unless the parameter \fIaddEmpty\fP is initialized to
\fItrue\fP\&.
.IP o 
\fBvoid clear()\fP:
.br 
This member clears the table\&. All existing elements are removed, and
the table will be empty\&.
.IP o 
\fBvoid fill(InputIterator begin, InputIterator end)\fP:
.br 
This member is defined as a template; \fIInputIterator\fP is a template
type parameter representing any input iterator\&. It can also be, e\&.g\&., a
pointer to an insertable type\&. The iterators must point to data elements which
can be inserted into an \fIstd::ostream\fP\&. The range of values implied by the
member\&'s iterator pair are inserted into the table as new elements\&.
.IP o 
\fBvoid push_back(std::string const &element)\fP:
.br 
This member can be used to add another element to the table (it is
also called from a \fIback_inserter\fP adaptor)\&.
.IP o 
\fBsize_t nRows()\fP:
.br 
This member returns the currently available number of rows in the
table\&. Its value is only defined after calling \fBdef()\fP\&.
.IP o 
\fBTable &setAlign(Align const &align)\fP:
.br 
This member is used to specify the alignment of either a column or an
element of the \fBTable\fP object\&. The standard alignments \fIstd::left,
std::right\fP and \fIstd::internal\fP may be specified, but in addition the
alignment \fIFBB::center\fP may be used if elements should be centered into
their column\&. A construction like
.nf 
tab << Align(2, FBB::center)
.fi 
requests centering of all elements in table column having index value 2
(i\&.e\&., the table\&'s 3rd column), whereas a construction like
.nf 
tab << Align(2, 3, FBB::center)
.fi 
requests centering of element [2][3]\&. It is the responsibility of the
programmer to ensure that such elements exist\&. By default, all elements are
right-aligned\&.
.IP o 
\fBTable &def()\fP:
.br 
This member may be used to `complete\&' a \fBTable\fP object to a full
rectangular object, for which all column widths and alignments have been
determined\&. It is implied by \fIoperator<<(ostream, Table)\fP\&. In
other situations it may be called explicitly to force the insertion of another
row in a table using \fIROWWISE\fP insertions\&. With \fICOLUMNWISE\fP insertions
its working is complex, since new elements added to a \fICOLUMNWISE\fP filled
table will reshuffle its elements over the table\&'s columns\&. 

.PP 
.SH "MANPULATORS"
.IP o 
\fBTable &def(Table &table)\fP:
.br 
This manipulator can be inserted into a table to call the table\&'s
\fBdef()\fP member\&.

.PP 
.SH "EXAMPLE"

.PP 
.nf 
#include <iostream>
#include <string>
#include <algorithm>

#include <bobcat/fnwrap1c>
#include <bobcat/table>

using namespace std;
using namespace FBB;

class Support: public TableSupport
{
    public:
        virtual void hline(size_t row) const;
        virtual void vline(size_t col) const;
        virtual void vline() const;
    private:
        static void outLine(Element const &element, ostream &out);
};

void Support::hline(size_t row) const
{
    if (row == 0 || row == nRows())
        out() << setfill(\&'-\&') << setw(width()) << "-" << setfill(\&' \&');
    else  
    {
        const_iterator fieldIt = begin(row);

        if (fieldIt == end())
            return;

        for_each(fieldIt, end(), 
                FnWrap1c<Element const &, ostream &>(outLine, out()));
    }
    out() << endl;
}

void Support::outLine(Element const &element, ostream &out)
{
    if (element\&.width == 0)
        return;

    if (element\&.type == SKIP)
        out << setw(element\&.width) << " ";
    else
        out << setfill(\&'-\&') << setw(element\&.width) << "-" << setfill(\&' \&');
}

void Support::vline(size_t col) const
{
    if (col < sep()\&.size())
        out() << sep()[col];
}

void Support::vline() const
{
    vline(nColumns());
    out() << "\en";
}


int main(int argc, char **argv)
{
    Support support;

    support << 0 << " | " << " | ";

    support << Support::HLine(1, 1, 3); // row[1] separator for cols 1 and 2

    Table tab(support, 3, Table::ROWWISE, Table::EQUALWIDTH);
//    Table tab(support, 3, Table::ROWWISE);
 
    tab << Align(0, std::left);     // set column non-default alignment
    tab\&.fill(argv + 1, argv + argc);// fill range of values
    cout << tab << endl;            // complete the table and insert
 
    tab << "hello" << "" << "wo";   // add additional elements\&.
    if (tab\&.nRows() > 2)
        tab << Align(2, 2, center); // set the layout of a specific element
 
    cout << tab << endl;

    return 0;
}

.fi 

.PP 
.SH "FILES"
\fIbobcat/table\fP - defines the class interface;
.br 

.PP 
.SH "SEE ALSO"
\fBbobcat\fP(7), \fBalign\fP(3bobcat), \fBtablesupport\fP(3bobcat)
.PP 
.SH "BUGS"
Note that \fIdef()\fP will reshuffle elements over the table\&'s
columns when new elements are added to the table subsequent to calling
\fIdef()\fP
.PP 
.SH "DISTRIBUTION FILES"
.IP o 
\fIbobcat_1\&.14\&.1-x\&.dsc\fP: detached signature;
.IP o 
\fIbobcat_1\&.14\&.1-x\&.tar\&.gz\fP: source archive;
.IP o 
\fIbobcat_1\&.14\&.1-x_i386\&.changes\fP: change log;
.IP o 
\fIlibbobcat1_1\&.14\&.1-x_i386\&.deb\fP: debian package holding the
libraries;
.IP o 
\fIlibbobcat1-dev_1\&.14\&.1-x_i386\&.deb\fP: debian package holding the
libraries, headers and manual pages;
.IP o 
\fIhttp://sourceforge\&.net/projects/bobcat\fP: public archive location;

.PP 
.SH "BOBCAT"
Bobcat is an acronym of `Brokken\&'s Own Base Classes And Templates\&'\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 
