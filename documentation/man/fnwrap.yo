includefile(include/header)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(FBB::FnWrap)(3bobcat)(_CurYrs_)(libbobcat1-dev__CurVers_-x.tar.gz)
                    (Configurable Function Wrapper)

manpagename(FnWrap)(Generic configurable context function wrapper class)

manpagesynopsis()
    bf(#include <bobcat/fnwrap>)nl()

manpagedescription()
    The bf(FBB::FnWrap) class traditionally contains two static members:
tt(unary) and tt(binary). These functions are still available, but since
Bobcat version 2.15.00 they have identical implementations and are in fact
superseded by the new free function tt(FBB::context) (see below).  All three
functions return the appropriate (unary or binary) functor that is ordinarily
called from generic algorithms of the standard template library, expecting a
unary or binary functor or predicate.

In this description there's no further reference to 
tt(FnWrap::unary) and tt(FnWrap::binary). Instead, tt(FBB::context) is
referred to, usually as just tt(context). Instead of tt(context) the functions
tt(FnWrap::unary) or tt(FnWrap::binary) could be used as
well. tt(FnWrap::unary) and tt(FnWrap::binary) will continue to be available
in future versions of Bobcat.

The tt(context) function expects the name of a (static or free)
function that is called by the functor's function operator. The
arguments received by the functor's function operator are forwarded to this
static or free function.

Any additional arguments that are passed to tt(context) are forwarded to the
function called by the functor's function operator. This allows users of
tt(FnWrap) to pass a em(local context) to the function that is indirectly
called by a generic algorithm.

The number and types of arguments are determined by the parameter list of the
function specified as first argument of tt(context). If that function, in
addition to parameters matching the types of the arguments provided by the
generic algorithm also defines, e.g., an tt(int) and a tt(std::string &)
parameter, then tt(context) must be called with arguments being, respectively,
the address of the function to call, an tt(int) argument and a tt(std::string)
em(lvalue).

The type of the return value of the function that is passed to tt(context)
also becomes the return type of the functor's function call operator. So if
the generic algorithm expects a predicate function the function called by the
functor's function call operator should return a tt(bool) value.

The called function must be a static member or free function. Using a static
member or free function has several advantages over calling a non-static 
class member function:
    itemization(
    it() No object for which the member function will be called is required;
    it() There is no introduced uncertainty about the bf(const)-ness of the
callled function, as static member functions and free functions do not support
bf(const) modifiers;
    it() The called function can be a static member function of the class
using the generic algorithm to which the bf(FnWrap) object is passed. By
specifying the calling object as one of the arguments of tt(context), the
called function will receive this object as well and may directly access the
calling object's members;
    it() The passed function can be a static member function of the class
whose objects are passed to the function via the generic template function's
iterator parameters. In that case the function may directly access the passed
object's members.
    it() Since no object is involved in calling the static function, no
ambiguity can arise as to whether an object reference or an object pointer
should be used in calling the function: static (member) functions may be
called without using objects.
    )

includefile(include/namespace)

manpagesection(INHERITS FROM)
    -

manpagesection(FREE FUNCTION)
    itemization(
    itb(Functor context(Function [, Arguments]))
        This function is defined in the namespace tt(FBB). nl()
        tt(Functor) represents the (unary or binary) functor that can be used
by generic algorithms;nl()
        tt(Function) is the name of a static member or free function that is
called from the tt(Functor)'s function operator. The type of its first
argument (or first two arguments if a binary functor is used) must match the
type(s) of the argument(s) received by the functor's function call
operator. Any additional parameters it may define must match, in types and
number, the additional arguments that are passed to
tt(context). tt(Function)'s return type becomes the return type of
tt(Functor)'s function call operator. If a value is returned by tt(Function)
that value will be returned by tt(Functor)'s function call operator.
    )

manpagesection(STATIC MEMBERS)
    itemization(
    itb(Functor unary(Function [, Arguments]))
        See tt(FBB::context)'s description.

    itb(Functor binary(Function [, Arguments]))
        See tt(FBB::context)'s description.
    )

manpagesection(TYPEDEFS)

   The functors defines types, that may be required by generic algorithms:
    itemization(
    itb(first_argument_type), a synonym for the basic type of the argument
received by the unary functor's function call operator and of the first
argument received by the binary functor's function call operator. E.g., if
the actual type is tt(std::string const *) then tt(argument_type) will
be tt(std::string);
    itb(second_argument_type), a synonym for the basic type of the second
argument received by the binary functor's function call operator.
    itb(result_type), a synonym for the basic type of the return type of the 
functor's function call operator.
    )

manpagesection(EXAMPLES)
        verb(
    // accumulating strings from a vector to one big string, using
    // `accumulate'
    #include <iostream>
    #include <numeric>
    #include <string>
    #include <vector>
    #include <bobcat/fnwrap>
    
    using namespace std;
    using namespace FBB;
    
    class Strings
    {
        vector<string> d_vs;
    
        public:
            Strings()
            :
                d_vs({"one", "two", "three"})
            {}
    
            void display(ostream &out) const
            {
                size_t count = 0;
    
                cout << "On Exit: " <<
                    accumulate(
                        d_vs.begin(), d_vs.end(),
                        string("HI"),
                        context(show, count, out)) << '\n';
                    
            }
    
        private:
            static string show(string const &str1,
                                    string const &str2,
                                    size_t &nr, ostream &out)
            {
                out << ++nr << " " << str1 << " " << str2 << '\n';

                return str1 + " " + str2;
            }
    };
    
    int main()
    {
        Strings s;
        s.display(cout);
    }
        )
    After compilation and linking, simply call the program without any
arguments. 

manpagefiles()
    em(bobcat/fnwrap) - defines the class interface

manpageseealso()
    bf(bobcat)(7), bf(foreach)(3bobcat), bf(repeat)(3bobcat)

manpagebugs()
    None Reported.

includefile(include/trailer)
